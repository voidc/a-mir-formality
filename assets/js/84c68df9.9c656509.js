"use strict";(self.webpackChunka_mir_formality=self.webpackChunka_mir_formality||[]).push([[718],{3905:function(e,t,n){n.d(t,{Zo:function(){return m},kt:function(){return d}});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},m=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,s=e.parentName,m=l(e,["components","mdxType","originalType","parentName"]),h=p(n),d=i,u=h["".concat(s,".").concat(d)]||h[d]||c[d]||o;return n?a.createElement(u,r(r({ref:t},m),{},{components:n})):a.createElement(u,r({ref:t},m))}));function d(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,r=new Array(o);r[0]=h;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:i,r[1]=l;for(var p=2;p<o;p++)r[p]=n[p];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},3034:function(e,t,n){n.r(t),n.d(t,{assets:function(){return m},contentTitle:function(){return s},default:function(){return d},frontMatter:function(){return l},metadata:function(){return p},toc:function(){return c}});var a=n(7462),i=n(3366),o=(n(7294),n(3905)),r=["components"],l={sidebar_position:1},s="Case study: Implied bounds and perfect derive",p={unversionedId:"what-formality-can-do/case-study",id:"what-formality-can-do/case-study",title:"Case study: Implied bounds and perfect derive",description:"The current code doesn't really model Rust as it is today.",source:"@site/docs/what-formality-can-do/case-study.md",sourceDirName:"what-formality-can-do",slug:"/what-formality-can-do/case-study",permalink:"/a-mir-formality/docs/what-formality-can-do/case-study",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/what-formality-can-do/case-study.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"What formality can do",permalink:"/a-mir-formality/docs/category/what-formality-can-do"},next:{title:"Conventions",permalink:"/a-mir-formality/docs/conventions"}},m={},c=[{value:"Distinguish <code>has-impl</code> and <code>is-implemented</code>",id:"distinguish-has-impl-and-is-implemented",level:3},{value:"But wait, implied bounds?",id:"but-wait-implied-bounds",level:3},{value:"Enter: invariants",id:"enter-invariants",level:3},{value:"Integrating invariants into the solver",id:"integrating-invariants-into-the-solver",level:3},{value:"Wait, so is this sound?",id:"wait-so-is-this-sound",level:3}],h={toc:c};function d(e){var t=e.components,n=(0,i.Z)(e,r);return(0,o.kt)("wrapper",(0,a.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"case-study-implied-bounds-and-perfect-derive"},"Case study: Implied bounds and perfect derive"),(0,o.kt)("p",null,"The ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/nikomatsakis/rust-name-resolution-algorithm/tree/ccc9599e0db39afa3516cedf059e434d0810be6f"},"current code"),' doesn\'t really model Rust as it is today.\nIt actually models Rust extended with support for two new features:\n"implied bounds" and "perfect derive".'),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Implied bounds:"),"\nGiven ",(0,o.kt)("inlineCode",{parentName:"p"},"struct Foo<T: Ord>"),", can ",(0,o.kt)("inlineCode",{parentName:"p"},"impl<T> Foo<T> { ... }")," just know that ",(0,o.kt)("inlineCode",{parentName:"p"},"T: Ord"),"?\nWe actually have implied bounds today, but they are limited to supertraits (e.g., ",(0,o.kt)("inlineCode",{parentName:"p"},"T: Eq => T: PartialEq"),"),\nso maybe a better way to describe implied bounds would be ",(0,o.kt)("em",{parentName:"p"},"expanded implied bounds"),"."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Perfect derive:"),"\nGiven ",(0,o.kt)("inlineCode",{parentName:"p"},"#[derive(Clone)] struct Foo<T> { x: Rc<T> }"),',\nwe "just know" that ',(0,o.kt)("inlineCode",{parentName:"p"},"impl<T> Clone for Foo<T>")," works,\nand that ",(0,o.kt)("inlineCode",{parentName:"p"},"T: Clone")," is not necessary?\nThe idea is that ",(0,o.kt)("inlineCode",{parentName:"p"},"derive")," would generate ",(0,o.kt)("inlineCode",{parentName:"p"},"impl<T> Clone for Foo<T> where Rc<T>: Clone"),".\nSeems simple, right?\nThe trick is that we have to extend all trait matching to work like auto-traits does,\nand accept cycles.\nConsider deriving clone on * ",(0,o.kt)("inlineCode",{parentName:"p"},"struct List<T> { value: Rc<T>, next: Option<Rc<List<T>>> }"),".\nHere you would get ",(0,o.kt)("inlineCode",{parentName:"p"},"impl<T> Clone for List<T> where Rc<T>: Clone, Option<Rc<List<T>>>: Clone"),".\nIf you try that today, you'll find it is a cycle error.\nWe are going to refer to this \"accept cycles\" as coinductive;\nit's basically the co-LP formulation by ",(0,o.kt)("a",{parentName:"p",href:"https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.102.9618&rep=rep1&type=pdf"},"Luke Simon et al.")," that I referred to earlier."),(0,o.kt)("p",null,"These two features are a bit tricky to integrate because accepting cycles,\nif you're not careful, can easily lead you into assuming implied bounds that are not true.\nThe classic example is this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"trait Copy { }\ntrait Magic: Copy { }\n")),(0,o.kt)("p",null,"Clearly, given these traits, we know that ",(0,o.kt)("inlineCode",{parentName:"p"},"T: Magic => T: Copy"),", right?\nBut what about if someone writes this rather tautological impl:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"impl<T: Magic> Magic for T { }\n")),(0,o.kt)("p",null,"If we're not careful, we can use this impl to show that every type implements ",(0,o.kt)("inlineCode",{parentName:"p"},"Magic")," --\nand yet there is no ",(0,o.kt)("inlineCode",{parentName:"p"},"impl Copy")," anywhere.\nSomething is off!"),(0,o.kt)("p",null,"The solution to that is based on the scheme that ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/scalexm"},"scalexm"),' invented for Chalk;\nI\'ve tweaked it somewhat by integrating it a bit more deeply into the "core logic",\nwhich simplifies the predicates that we need.\nI find I like this formulation better, and it allows us to simplify a few other things too.'),(0,o.kt)("h3",{id:"distinguish-has-impl-and-is-implemented"},"Distinguish ",(0,o.kt)("inlineCode",{parentName:"h3"},"has-impl")," and ",(0,o.kt)("inlineCode",{parentName:"h3"},"is-implemented")),(0,o.kt)("p",null,"The first key part of the system\nis to distinguish ",(0,o.kt)("em",{parentName:"p"},"having an impl")," (",(0,o.kt)("inlineCode",{parentName:"p"},"has-impl"),") from ",(0,o.kt)("em",{parentName:"p"},"being implemented")," (",(0,o.kt)("inlineCode",{parentName:"p"},"is-implemented"),").\nThe former says that the user wrote an ",(0,o.kt)("inlineCode",{parentName:"p"},"impl")," block.\nThe latter says that all the requirements are met to implement the trait,\nincluding in particular that all of its where clauses (which includes the supertraits) are satisfied."),(0,o.kt)("p",null,"Using the code for impls we saw earlier, the ",(0,o.kt)("inlineCode",{parentName:"p"},"Magic")," impl would generate the following clause:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scheme"},"; forall<T> { is-implemented(T: Magic) => has-impl(T: Magic) }\n(\u2200 ((type T)) \n        (implies ((is-implemented (Magic (T))))\n                 (has-impl (Magic (T)))))\n")),(0,o.kt)("p",null,"To actually prove ",(0,o.kt)("inlineCode",{parentName:"p"},"is-implemented(T: Magic)"),",\nthis clause has to be combined with the clauses generated by the trait declarations (",(0,o.kt)("a",{parentName:"p",href:"https://github.com/nikomatsakis/a-mir-formality/blob/47eceea34b5f56a55d781acc73dca86c996b15c5/src/decl/decl-to-clause.rkt#L95-L118"},"source"),").\nFor the ",(0,o.kt)("inlineCode",{parentName:"p"},"Copy")," trait, which has no where clauses, this clause is very simple.\nTo be implemented, the impl must exist, and the type must be well-formed:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scheme"},"; forall<T> { (\n;               has-impl(T: Copy), \n;               well-formed(T),\n;             ) => is-implemented(T: Copy) }\n(\u2200 ((type T))\n        (implies ((has-impl (Copy (T)))\n                  (well-formed (type (T))))\n                 (is-implemented (Copy (T)))))\n")),(0,o.kt)("p",null,"For ",(0,o.kt)("inlineCode",{parentName:"p"},"Magic"),", the rule includes the where clause that ",(0,o.kt)("inlineCode",{parentName:"p"},"T: Copy"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scheme"},"; forall<T> { (\n;               has-impl(T: Magic), \n;               well-formed(T),\n;               is-implemented(T: Copy),\n;             ) => is-implemented(T: Magic) }\n(\u2200 ((type T))\n        (implies ((has-impl (Magic (T)))\n                  (well-formed (type (T)))\n                  (is-implemented (Copy (T))))\n                 (is-implemented (Magic (T)))))\n")),(0,o.kt)("p",null,"Now we start to see how this works --\nif I want to call a function with a ",(0,o.kt)("inlineCode",{parentName:"p"},"T: Magic")," where clause, like this..."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"fn make_the_magic_happen<T: Magic>(t: T) {\n    let u = t;\n    drop((t, u)); // both t, u are valid\n}\n")),(0,o.kt)("p",null,"...it is not enough to show that ",(0,o.kt)("inlineCode",{parentName:"p"},"has-impl")," is satisfied, I also have to prove that ",(0,o.kt)("inlineCode",{parentName:"p"},"T: Copy"),"\nTo do that, I have to show that ",(0,o.kt)("inlineCode",{parentName:"p"},"has-impl(T: Copy)"),", and I can't do that."),(0,o.kt)("h3",{id:"but-wait-implied-bounds"},"But wait, implied bounds?"),(0,o.kt)("p",null,"Actually though, the above is not sufficient to solve the problem\nThat's because we haven't added in implied bounds yet! The ",(0,o.kt)("em",{parentName:"p"},"naive")," version of implied bounds is that we want to add in a rule like so:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"is-implemented(T: Magic) => is-implemented(T: Copy)\n")),(0,o.kt)("p",null,"i.e., if I know that ",(0,o.kt)("inlineCode",{parentName:"p"},"T: Magic"),", I also know that ",(0,o.kt)("inlineCode",{parentName:"p"},"T: Copy"),"\nBut if we literally added that clause, it would be unsound, at least in a coinductive setting\nWhy is that? Say I want to prove that ",(0,o.kt)("inlineCode",{parentName:"p"},"String: Copy"),"..."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"is-implemented(String: Copy)"),"? Well, that's true if...",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"is-implemented(String: Magic)"),"? Well, that's true if...",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"has-impl(String: Magic)"),"? Well, that's true if...",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"is-implemented(String: Magic)")," -- and that's on the stack, so that's ok!"))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"well-formed(String)")," -- yep"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"is-implemented(String: Copy)")," -- well, that's on the stack, so that's ok!")))))),(0,o.kt)("p",null,"The traditional solution so this sort of problem is to impose some kind of limits on the impls people can write so they must be \"productive\"\nIt's a bit tricky to define what productivity means, but intuitively it means \"not tautological\"\nThe challenge is that the various schemes I've seen for showing productivity don't accept impls like the ones that perfect derive would create, so they wouldn't really work for us.\nThe solution in the impl works a different way."),(0,o.kt)("p",null,'The co-LP formulation acccepts any cycle as valid, so it\'s very easy to create these kind of "tautological rules".\nNow, if the user actually ',(0,o.kt)("em",{parentName:"p"},"wrote")," those impls, I don't see that as a problem.\nIt's ok to have mutually dependent impls, all we want to know basically is \"when I call a method, there will be some impl to go to\" (see example below).\nBut it's not good if it's unsound. =)"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"trait Foo {\n    fn foo(&self);\n}\n\ntrait Bar {\n    fn bar(&self);\n}\n\nimpl<T: Bar> Foo for T {\n    fn foo(&self) {\n        if something() { self.bar() }\n    }\n}\n\nimpl<T: Foo> Bar for T {\n    fn bar(&self) {\n        if something() { self.foo() }\n    }\n}\n")),(0,o.kt)("h3",{id:"enter-invariants"},"Enter: invariants"),(0,o.kt)("p",null,"The insight is that it's not ok to use implied bounds out of thin air.\nYou only want to use them for where-clauses that you have in scope.\nIn this way, they are categorically different from program clauses, which always hold.\nI've decided to refer to implied bounds as ",(0,o.kt)("em",{parentName:"p"},"invariants"),' -- the idea is that they are things which "must be true if the program is valid".\nSo for our program we would have one ',(0,o.kt)("strong",{parentName:"p"},"invariant"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"forall<T> { is-implemented(T: Magic) => is-implemented(T: Copy) }\n")),(0,o.kt)("p",null,"To express this a bit more formally, let ",(0,o.kt)("inlineCode",{parentName:"p"},"F"),' be the set of all "facts" we can generate from the clauses alone (a "fact" here is just a predicate that refers to some concrete types and thing)s.\nBecause there are an infinite set of types, the set of facts is also infinite, but that\'s ok.\nIn our example, given the rules we\'ve seen so far (but ignoring the implied bound), we can show that ',(0,o.kt)("inlineCode",{parentName:"p"},"has-impl(i32: Magic)")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"has-impl(u32: Magic)")," easily enough.\nWe don't have a ",(0,o.kt)("inlineCode",{parentName:"p"},"has-impl(i32: Copy)")," fact, though, and because of that we also can't have a ",(0,o.kt)("inlineCode",{parentName:"p"},"is-implemented(i32: Copy)")," fact.\nGiven this set of facts ",(0,o.kt)("inlineCode",{parentName:"p"},"F"),", then we ought to be able to prove each invariant ",(0,o.kt)("inlineCode",{parentName:"p"},"I"),", or something is broken in our type rules.\nIn our example, the invariant ",(0,o.kt)("inlineCode",{parentName:"p"},"forall<T> { is-implemented(T: Magic) => is-implemented(T: Copy) }")," does in fact hold, because there are no ",(0,o.kt)("inlineCode",{parentName:"p"},"is-implemented(T: Magic)")," facts."),(0,o.kt)("h3",{id:"integrating-invariants-into-the-solver"},"Integrating invariants into the solver"),(0,o.kt)("p",null,"The solver is able to make use of invariants to generate proofs, but only in a limited way.\nWhereas we can always use a program clause, we can only apply invariants to the ",(0,o.kt)("em",{parentName:"p"},"hypotheses")," that are in scope -- a ",(0,o.kt)("em",{parentName:"p"},"hypotheses")," is some where-clause that we are assuming to be true.\nThe idea here is that the caller must have proven that hypothesis to be a ",(0,o.kt)("em",{parentName:"p"},"fact")," -- if they did so, then unless our type rules are broken, the invariant holds, which means that any facts we can derive with the invariants are also true."),(0,o.kt)("p",null,"This in turn implies that the seemingly tautological impl of ",(0,o.kt)("inlineCode",{parentName:"p"},"Magic")," is actually ",(0,o.kt)("strong",{parentName:"p"},"legal"),'! Recall the "ok goals" we saw before, that are used to decide which declarations are legal.\nThe "ok" goal for the magic impl looks like this:'),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scheme"},"(\u2200 ((type T))\n        (implies ((is-implemented (Magic (T))))\n                 (is-implemented (Magic (T)))))\n")),(0,o.kt)("p",null,'Basically, "if we assume that ',(0,o.kt)("inlineCode",{parentName:"p"},"T: Magic")," is implemented, then we can show that ",(0,o.kt)("inlineCode",{parentName:"p"},"T: Magic")," is implemented\".\nWell, that's obviously true."),(0,o.kt)("p",null,"OK, so the impl is legal, but what about this function ",(0,o.kt)("inlineCode",{parentName:"p"},"make_the_magic_happen"),"?"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"fn make_the_magic_happen<T: Magic>(t: T) {\n    let u = t;\n    drop((t, u)); // both t, u are valid\n}\n")),(0,o.kt)("p",null,"We don't currently have type-checking logic in Formality\nbut, if we did, type-checking this function would require copying ",(0,o.kt)("inlineCode",{parentName:"p"},"t")," and hence proving that:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"forall<T> {\n    is-implemented(T: Magic) => is-implemented(T: Copy)\n}\n")),(0,o.kt)("p",null,"Here the ",(0,o.kt)("inlineCode",{parentName:"p"},"is-implemented(T: Magic) => ...")," comes from the where-clauses on the function.\nTo solve this, the solver puts ",(0,o.kt)("inlineCode",{parentName:"p"},"is-implemented(T: Magic)"),' into the environment as a hypothesis using the "prove-implies" rule (',(0,o.kt)("a",{parentName:"p",href:"https://github.com/nikomatsakis/a-mir-formality/blob/47eceea34b5f56a55d781acc73dca86c996b15c5/src/ty/cosld-solve/prove.rkt#L67-L71"},"source"),"):"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scheme"},'  [(where Env_1 (env-with-hypotheses Env Hypotheses))\n   (prove Env_1 Predicates_stack Goal EnvSubstitution_out)\n   -------------------------------------------------------- "prove-implies"\n   (prove Env Predicates_stack (implies Hypotheses Goal) (reset Env () EnvSubstitution_out))\n   ]\n')),(0,o.kt)("p",null,'Next it can apply the "prove-hypothesis-imply" rule (',(0,o.kt)("a",{parentName:"p",href:"https://github.com/nikomatsakis/a-mir-formality/blob/47eceea34b5f56a55d781acc73dca86c996b15c5/src/ty/cosld-solve/prove.rkt#L41-L45"},"source"),"):"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scheme"},'  [(where #f (in? Predicate Predicates_stack))\n   (Hypotheses-imply Env () Predicate EnvSubstitution_out)\n   --------------- "prove-hypotheses-imply"\n   (prove Env Predicates_stack Predicate EnvSubstitution_out)\n   ]\n')),(0,o.kt)("p",null,"This rule usess ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/nikomatsakis/a-mir-formality/blob/47eceea34b5f56a55d781acc73dca86c996b15c5/src/ty/cosld-solve/hypothesize.rkt#L9-L11"},(0,o.kt)("inlineCode",{parentName:"a"},"Hypotheses-imply")),", another typing judgment which determines whether ",(0,o.kt)("inlineCode",{parentName:"p"},"Predicate")," is either ",(0,o.kt)("em",{parentName:"p"},"directly")," in the environment as a hypothesis ",(0,o.kt)("strong",{parentName:"p"},"or can be derived via an invariant"),".\nThis last part is what we need here! The only hypothesis in the environment is ",(0,o.kt)("inlineCode",{parentName:"p"},"is-implemented(T: Magic)"),", but we can use the invariant"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"is-implemented(T: Magic) => is-implemented(T: Copy)\n")),(0,o.kt)("p",null,"to expand that to ",(0,o.kt)("inlineCode",{parentName:"p"},"is-implemented(T: Copy)"),", so we are happy."),(0,o.kt)("h3",{id:"wait-so-is-this-sound"},"Wait, so is this sound?"),(0,o.kt)("p",null,"But accepting this impl and this function this doesn't mean we have an unsound program -- the question is, who is going to ",(0,o.kt)("em",{parentName:"p"},"call")," that function, and with what type? And this is where the errors come in.\nConsider this ",(0,o.kt)("inlineCode",{parentName:"p"},"main")," function:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'fn main() {\n    make_the_magic_happen("Die, cruel world, die!".to_string());\n}\n')),(0,o.kt)("p",null,"For this program to type-check, we must prove the where-clauses on ",(0,o.kt)("inlineCode",{parentName:"p"},"make_the_magic_happen"),", which means proving"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"is-implemented(String: Magic)\n")),(0,o.kt)("p",null,"But in this case, there are no hypotheses in the environment, so we can't make use of the invariants.\nWe have to use the program clause, it requires also showing that ",(0,o.kt)("inlineCode",{parentName:"p"},"is-implemented(String: Copy)")," which in turn means showing ",(0,o.kt)("inlineCode",{parentName:"p"},"has-impl(String: Copy)"),", and we cannot do that."),(0,o.kt)("p",null,'Thinking a bit more abstractly, no matter what where clauses we have on various functions, we will "bottom out" in a ',(0,o.kt)("inlineCode",{parentName:"p"},"main")," function somewhere, and ",(0,o.kt)("inlineCode",{parentName:"p"},"main")," has no where clauses.\nTherefore, if our program relies on ",(0,o.kt)("inlineCode",{parentName:"p"},"is-implemented(i32: Magic)"),", that must be provable in an environment with no hypotheses.\nPut another way, ",(0,o.kt)("inlineCode",{parentName:"p"},"is-implemented(i32: Magic)"),' must be a member of that infinite set of facts that we described earlier, the ones which categorize "everything that is true in this program".\nBut we already argued that this set does not include ',(0,o.kt)("inlineCode",{parentName:"p"},"is-implemented(i32: Magic)"),", because the only way to get such a fact is to use the program clause, and the program clause requires that ",(0,o.kt)("inlineCode",{parentName:"p"},"has-impl(i32: Copy)"),", which is not true."))}d.isMDXComponent=!0}}]);