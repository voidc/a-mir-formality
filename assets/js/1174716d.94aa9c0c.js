"use strict";(self.webpackChunka_mir_formality=self.webpackChunka_mir_formality||[]).push([[312],{3905:function(e,t,a){a.d(t,{Zo:function(){return m},kt:function(){return c}});var i=a(7294);function n(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function l(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,i)}return a}function r(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?l(Object(a),!0).forEach((function(t){n(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,i,n=function(e,t){if(null==e)return{};var a,i,n={},l=Object.keys(e);for(i=0;i<l.length;i++)a=l[i],t.indexOf(a)>=0||(n[a]=e[a]);return n}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(i=0;i<l.length;i++)a=l[i],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(n[a]=e[a])}return n}var s=i.createContext({}),p=function(e){var t=i.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):r(r({},t),e)),a},m=function(e){var t=p(e.components);return i.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},h=i.forwardRef((function(e,t){var a=e.components,n=e.mdxType,l=e.originalType,s=e.parentName,m=o(e,["components","mdxType","originalType","parentName"]),h=p(a),c=n,d=h["".concat(s,".").concat(c)]||h[c]||u[c]||l;return a?i.createElement(d,r(r({ref:t},m),{},{components:a})):i.createElement(d,r({ref:t},m))}));function c(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var l=a.length,r=new Array(l);r[0]=h;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:n,r[1]=o;for(var p=2;p<l;p++)r[p]=a[p];return i.createElement.apply(null,r)}return i.createElement.apply(null,a)}h.displayName="MDXCreateElement"},9760:function(e,t,a){a.r(t),a.d(t,{assets:function(){return m},contentTitle:function(){return s},default:function(){return c},frontMatter:function(){return o},metadata:function(){return p},toc:function(){return u}});var i=a(7462),n=a(3366),l=(a(7294),a(3905)),r=["components"],o={author:"nikomatsakis"},s="a MIR Formality, goals and the reality",p={permalink:"/a-mir-formality/blog/2022/05/12/",editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2022-05-12.mdx",source:"@site/blog/2022-05-12.mdx",title:"a MIR Formality, goals and the reality",description:"This is a document that was prepared for the 2022-03-18 types team deep dive (read the transcript from that meeting).",date:"2022-05-12T00:00:00.000Z",formattedDate:"May 12, 2022",tags:[],readingTime:30.885,truncated:!1,authors:[{name:"nikomatsakis"}],frontMatter:{author:"nikomatsakis"}},m={authorsImageUrls:[void 0]},u=[{value:"How I see formality being used",id:"how-i-see-formality-being-used",level:2},{value:"Why a new repo? Why PLT redex?",id:"why-a-new-repo-why-plt-redex",level:2},{value:"Formality and the types team",id:"formality-and-the-types-team",level:2},{value:"Layers of formality",id:"layers-of-formality",level:2},{value:"A closer look at formality-ty",id:"a-closer-look-at-formality-ty",level:2},{value:"Defining Rust types",id:"defining-rust-types",level:3},{value:"Type unification",id:"type-unification",level:3},{value:"Predicates",id:"predicates",level:3},{value:"Solver",id:"solver",level:3},{value:"A closer look at formality-decl",id:"a-closer-look-at-formality-decl",level:2},{value:"Declaring traits in <code>FormalityDecl</code>",id:"declaring-traits-in-formalitydecl",level:3},{value:"Lowering crate items to clauses",id:"lowering-crate-items-to-clauses",level:3},{value:"Generating the clauses for a single crate item",id:"generating-the-clauses-for-a-single-crate-item",level:3},{value:"Generating the &quot;ok goals&quot; for a crate",id:"generating-the-ok-goals-for-a-crate",level:3},{value:"Case study: Implied bounds and perfect derive",id:"case-study-implied-bounds-and-perfect-derive",level:2},{value:"Distinguish <code>has-impl</code> and <code>is-implemented</code>",id:"distinguish-has-impl-and-is-implemented",level:3},{value:"But wait, implied bounds?",id:"but-wait-implied-bounds",level:3},{value:"Enter: invariants",id:"enter-invariants",level:3},{value:"Integrating invariants into the solver",id:"integrating-invariants-into-the-solver",level:3},{value:"Wait, so is this sound?",id:"wait-so-is-this-sound",level:3},{value:"Productivity again?",id:"productivity-again",level:3},{value:"Future directions",id:"future-directions",level:2},{value:"If this is a complete model, isn&#39;t that just an implementation?",id:"if-this-is-a-complete-model-isnt-that-just-an-implementation",level:2},{value:"Are there any fundamental differences to Chalk, so far?",id:"are-there-any-fundamental-differences-to-chalk-so-far",level:2},{value:"Is this an &quot;ideal&quot; Rust model, or a &quot;practical&quot; one?",id:"is-this-an-ideal-rust-model-or-a-practical-one",level:2},{value:"Is it practical to try to develop Chalk alongside? I.e. update Chalk&#39;s rules as a-mir-formality is updated?",id:"is-it-practical-to-try-to-develop-chalk-alongside-ie-update-chalks-rules-as-a-mir-formality-is-updated",level:2},{value:"What about Coq?",id:"what-about-coq",level:2},{value:"How would types team signoff integrate into feature process?",id:"how-would-types-team-signoff-integrate-into-feature-process",level:2},{value:"How/where does coercion fit in?",id:"howwhere-does-coercion-fit-in",level:2}],h={toc:u};function c(e){var t=e.components,a=(0,n.Z)(e,r);return(0,l.kt)("wrapper",(0,i.Z)({},h,a,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("p",null,"This is a document that was prepared for the 2022-03-18 types team deep dive (",(0,l.kt)("a",{parentName:"p",href:"https://rust-lang.zulipchat.com/#narrow/stream/144729-wg-traits/topic/deep.20dive.202022-03-18.3A.20intro.20to.20formality"},"read the transcript from that meeting"),")."),(0,l.kt)("p",null,"From ",(0,l.kt)("a",{parentName:"p",href:"https://github.com/nikomatsakis/a-mir-formality"},"the repository")," (emphasis mine):"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"This repository is an early-stage experimental project that aims to be a complete, authoritative formal model of the ",(0,l.kt)("a",{parentName:"p",href:"https://rustc-dev-guide.rust-lang.org/mir/index.html"},"Rust MIR"),". ",(0,l.kt)("strong",{parentName:"p"},"Presuming these experiments bear fruit, the intention is to bring this model into Rust as an RFC and develop it as an official part of the language definition."))),(0,l.kt)("p",null,"The goal of this document is to explain the high-level structure as well as giving a sense for the overall development roadmap I have in mind."),(0,l.kt)("p",null,"[ToC]"),(0,l.kt)("h2",{id:"how-i-see-formality-being-used"},"How I see formality being used"),(0,l.kt)("p",null,'Formality will become the "primary source" for "what Rust means":'),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"When a new language feature is designed, one stage in the process will be formalizing that feature into formality. ",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},'Currently, since formality focuses on MIR, this will only make sense for "core language features" like implied bounds or specialization. Eventually I\'d like to extend formality to cover other areas like name resolution and Rust surface syntax.'),(0,l.kt)("li",{parentName:"ul"},"This will help to uncover interactions between features."))),(0,l.kt)("li",{parentName:"ul"},"Formality can be fuzzed and checked against rustc, much as the ",(0,l.kt)("a",{parentName:"li",href:"https://www.amazon.science/publications/using-lightweight-formal-methods-to-validate-a-key-value-storage-node-in-amazon-s3"},"AWS S3 team does to check their code"),".",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"We can extend rustc to generate formality declarations."))),(0,l.kt)("li",{parentName:"ul"},"For the trait solver, formality will map quite closely to its overall structure, which allows us to experiment with new algorithms or structure and see their effects quickly.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"As an initial example, I plan to prototype a new approach for associated type normalization.")))),(0,l.kt)("h2",{id:"why-a-new-repo-why-plt-redex"},"Why a new repo? Why PLT redex?"),(0,l.kt)("p",null,'I had originally hoped that chalk could serve as a kind of "executable semantics" for Rust. The idea was that the separation between "generating clauses" and "the solver" would allow us to specify how Rust works on a high-enough level that the code is nicely generic. Over time, though, I\'ve become convinced that this approach won\'t scale. There is a lot of "incidental complexity" that is created by integrating chalk into rustc, as well as engineering for efficiency. Ultimately, I don\'t see chalk being sufficiently malleable for our purposes.'),(0,l.kt)("p",null,"I chose to use PLT Redex because it's a really great tool for exploration. It allows you to write very high-level structures, execute them, and see what happens. I think it's sufficiently approachable that we can onboard contributors and grow the types team. I'm not sure the same is true of other alternatives. Plus I like it."),(0,l.kt)("h2",{id:"formality-and-the-types-team"},"Formality and the types team"),(0,l.kt)("p",null,'I imagine formality being "owned and maintained" by the types team, like other rust-lang projects. '),(0,l.kt)("h2",{id:"layers-of-formality"},"Layers of formality"),(0,l.kt)("p",null,"Formality is structured into several layers. These layers are meant to also map fairly closely onto chalk and the eventual Rust trait solver implementation. Ideally, one should be able to map back and forth between formality and the code with ease."),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"formality-ty:"),' the "types" layer',(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Defines Rust types and functions for equating/relating them.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},'The representation is meant to cover all Rust types, but is optimized for extracting their "essential properties".'))),(0,l.kt)("li",{parentName:"ul"},"Defines core logical predicates (",(0,l.kt)("inlineCode",{parentName:"li"},"is-implemented(T: Trait)"),", etc) and solvers.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"But doesn't define what they ",(0,l.kt)("em",{parentName:"li"},"mean")," -- i.e., the conditions in which they are true."))))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"formality-decl:"),' the "Rust declarations" layer',(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},'Defines Rust "top-level items" and their semantics',(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"This includes crates, structs, traits, impls, but excludes function bodies."))),(0,l.kt)("li",{parentName:"ul"},"Semantics are defined by converting Rust items into predicates",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"e.g., ",(0,l.kt)("inlineCode",{parentName:"li"},"impl<T: Eq> Eq for Vec<T>"),' becomes a "program clause" (axiom) like ',(0,l.kt)("inlineCode",{parentName:"li"},"forall<T> { is-implemented(T: Eq) => has-impl(Vec<T: Eq>) }")," (the distinction between ",(0,l.kt)("inlineCode",{parentName:"li"},"has-impl")," and ",(0,l.kt)("inlineCode",{parentName:"li"},"is-implemented")," is covered below)."))),(0,l.kt)("li",{parentName:"ul"},"Defines the well-formedness checks for those items",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"e.g., ",(0,l.kt)("inlineCode",{parentName:"li"},"struct Foo { f1: T1 }")," is well-formed if "))))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"formality-mir:"),' the "type system for MIR" layer',(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Defines MIR and rules for its type checker (corresponds roughly to the MIR borrow checker + polonius)."),(0,l.kt)("li",{parentName:"ul"},"Caveat: I've sketched this out, but nothing more."))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"formality-mir-op:"),' the "operational semantics for MIR" layer',(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Extends the above level with an operational semantics. Basically equivalent to miri."),(0,l.kt)("li",{parentName:"ul"},"Caveat: I haven't even sketched this out yet.")))),(0,l.kt)("h2",{id:"a-closer-look-at-formality-ty"},"A closer look at formality-ty"),(0,l.kt)("p",null,"Let's take a closer look at the formality-ty layer. "),(0,l.kt)("h3",{id:"defining-rust-types"},"Defining Rust types"),(0,l.kt)("p",null,"The current definition of types looks like this (",(0,l.kt)("a",{parentName:"p",href:"https://github.com/nikomatsakis/a-mir-formality/blob/47eceea34b5f56a55d781acc73dca86c996b15c5/src/ty/grammar.rkt#L25-L37"},"source"),"):"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scheme"},"(define-language formality-ty\n  ...\n  (Ty :=\n      (TyApply TyName Parameters) ; Application type\n      VarId                       ; Bound or existential (inference) variable\n      (! VarId)                   ; Universal (placeholder) variable\n      )\n  (TyName :=\n          AdtId           ; enum/struct/union\n          TraitId         ; trait\n          AssociatedTy    ; Associated type\n          ScalarId        ; Something like i32, u32, etc\n          (ref MaybeMut)  ; `&mut` or `&`, expects a lifetime + type parameter\n          (tuple number)  ; tuple of given arity\n          )\n   ...\n   (ScalarId := i8 u8 i16 u16 i32 u32 i64 u64 i128 u128 bool)\n   ...\n   (AssociatedTy := (TraitId AssociatedTyId))\n   ...\n   (Parameters := (Parameter ...))\n   (Parameter := Ty Lt)\n   ...\n   ((AdtId VarId TraitId AssociatedTyId AnyId) := variable-not-otherwise-mentioned)\n)\n")),(0,l.kt)("p",null,"As you can see, it's woefully incomplete, but it should give you some idea for the level of abstraction we are shooting for and also how PLT Redex works. The idea here is that a type is either a variable, a placeholder that represents a generic type, or an \"application\" of a type name to some parameters. Let's see some examples:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"A generic type like ",(0,l.kt)("inlineCode",{parentName:"li"},"T")," could either be ",(0,l.kt)("inlineCode",{parentName:"li"},"T")," or ",(0,l.kt)("inlineCode",{parentName:"li"},"(! T)"),":",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"T")," is used when the generic has yet to be substituted, e.g., as part of a declaration."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"(! T)"),' is used as a placeholder to "any type ',(0,l.kt)("inlineCode",{parentName:"li"},"T"),'".'))),(0,l.kt)("li",{parentName:"ul"},"A type like ",(0,l.kt)("inlineCode",{parentName:"li"},"Vec<T>")," in Rust would be represented therefore as:",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"(TyApply Vec (T))"),", in a declaration; or,"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"(TyApply Vec ((! T)))")," when checking it."))),(0,l.kt)("li",{parentName:"ul"},"A scalar type like ",(0,l.kt)("inlineCode",{parentName:"li"},"i32")," is represented as ",(0,l.kt)("inlineCode",{parentName:"li"},"(TyApply i32 ())"),".")),(0,l.kt)("p",null,"As I said, this defintion of types is woefully incomplete. I expect it to eventually include:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},'"alias types" like associated types and type aliases'),(0,l.kt)("li",{parentName:"ul"},'"existential" types like ',(0,l.kt)("inlineCode",{parentName:"li"},"dyn")),(0,l.kt)("li",{parentName:"ul"},'"forall" quantifies to cover ',(0,l.kt)("inlineCode",{parentName:"li"},"for<'a> ...")),(0,l.kt)("li",{parentName:"ul"},'"function" types ',(0,l.kt)("inlineCode",{parentName:"li"},"fn(A1...An) -> R")),(0,l.kt)("li",{parentName:"ul"},'"implication" types ',(0,l.kt)("inlineCode",{parentName:"li"},"where(...) T"),"-- these don't exist in Rust yet =)")),(0,l.kt)("p",null,'You can also see that the definition of types is aligned to highlight their "essential" characteristics and not necessarily for convenience elsewhere. Almost every Rust type, for example, boils down to ',(0,l.kt)("em",{parentName:"p"},"some"),' kind of "application" (it\'s likely that we can even represent ',(0,l.kt)("inlineCode",{parentName:"p"},"fn")," types this way)."),(0,l.kt)("h3",{id:"type-unification"},"Type unification"),(0,l.kt)("p",null,"A key part of the type layer is that it includes ",(0,l.kt)("em",{parentName:"p"},"type unification"),". That is, it defines the rules for making types equal. This will eventually have to be extended to cover subtyping (more on that a bit later) so that we can properly handle variance."),(0,l.kt)("p",null,'Unification is done via a "metafunction", which just means a function that operates on terms (versus a function in the Rust program being analyzed):'),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scheme"},"(define-metafunction formality-ty\n  most-general-unifier : Env TermPairs -> EnvSubstitution or Error\n")),(0,l.kt)("p",null,"This function takes an environment ",(0,l.kt)("inlineCode",{parentName:"p"},"Env")," and a list of pairs of terms that should be equated and gives back either:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"a new environment and substitution from inference variables to values that will make the two terms syntactically equal; or,"),(0,l.kt)("li",{parentName:"ul"},"the term ",(0,l.kt)("inlineCode",{parentName:"li"},"Error"),", if they cannot be unified.")),(0,l.kt)("p",null,"The unifier is a bit smarter than the traditional unification in that it knows about ",(0,l.kt)("em",{parentName:"p"},"universes"),' and so can handle "forall" proofs and things (that\'s what is found in the environment). This is the same as chalk and rustc. '),(0,l.kt)("p",null,"I won't cover the details but I'll just give an example. This is actually modified from a unit test from the code (",(0,l.kt)("a",{parentName:"p",href:"https://github.com/nikomatsakis/a-mir-formality/blob/47eceea34b5f56a55d781acc73dca86c996b15c5/src/ty/unify.rkt#L254-L269"},"source"),"). Invoking ",(0,l.kt)("inlineCode",{parentName:"p"},"most-general-unifier")," like so:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scheme"},"(most-general-unifier Env_2 ((A X)\n                             (X (TyApply Vec (Y)))\n                             (Y (TyApply i32 ()))))\n")),(0,l.kt)("p",null,"corresponds to saying that ",(0,l.kt)("inlineCode",{parentName:"p"},"[A = X, X = Vec<Y>, Y = i32]")," must all be true, where ",(0,l.kt)("inlineCode",{parentName:"p"},"A"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"X")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"Y")," are inference variables. The resulting output is a substitution that maps ",(0,l.kt)("inlineCode",{parentName:"p"},"A"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"X")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"Y")," to the following values:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"A -> Vec<i32>")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"X -> Vec<i32>")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"Y -> i32"))),(0,l.kt)("h3",{id:"predicates"},"Predicates"),(0,l.kt)("p",null,"Formality-ty also defines the core predicates used to define Rust semantics. The current definition is as follows (",(0,l.kt)("a",{parentName:"p",href:"https://github.com/nikomatsakis/a-mir-formality/blob/47eceea34b5f56a55d781acc73dca86c996b15c5/src/ty/grammar.rkt#L121-L130"},"source"),"):"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scheme"},"  (Predicate :=\n             ; `TraitRef` is (fully) implemented.\n             (is-implemented TraitRef)\n             ; an impl exists for `TraitRef`; this *by itself* doesn't mean\n             ; that `TraitRef` is implemented, as the supertraits may not\n             ; have impls.\n             (has-impl TraitRef)\n             ; the given type or lifetime is well-formed.\n             (well-formed (ParameterKind Parameter))\n             )\n")),(0,l.kt)("p",null,'These core predicates are then used to define a richer vocabulary of goals (things that can be proven) and various kinds of "clauses" (things that are assumed to be true, axioms) (',(0,l.kt)("a",{parentName:"p",href:"https://github.com/nikomatsakis/a-mir-formality/blob/47eceea34b5f56a55d781acc73dca86c996b15c5/src/ty/grammar.rkt#L136-L143"},"source"),"):"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scheme"},"  (Goals = (Goal ...))\n  (Goal :=\n        Predicate\n        (Equate Term Term)\n        (&& Goals)\n        (|| Goals)\n        (implies Hypotheses Goal)\n        (Quantifier KindedVarIds Goal)\n        )\n\n  ((Hypotheses Clauses Invariants) := (Clause ...))\n  ((Hypothesis Clause Invariant) :=\n                                 Predicate\n                                 (implies Goals Predicate)\n                                 (\u2200 KindedVarIds Clause)\n                                 )\n")),(0,l.kt)("p",null,"Importantly, the ",(0,l.kt)("em",{parentName:"p"},"types layer"),' defines a solver that gives semantics to all the "meta" parts of goals and clauses -- e.g., it defines what it means to prove ',(0,l.kt)("inlineCode",{parentName:"p"},"(&& (G1 G2))")," (prove both ",(0,l.kt)("inlineCode",{parentName:"p"},"G1")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"G2"),", duh). But it doesn't have any rules for what it means to prove the ",(0,l.kt)("em",{parentName:"p"},"core")," predicates true -- so it could never prove ",(0,l.kt)("inlineCode",{parentName:"p"},"(is-implemented (Debug ((! T))))"),'. Those rules all come from the declaration layer and are given to the types layer as part of the "environment".'),(0,l.kt)("p",null,"You might be curious about the distinction between goal and clause and why there are so many names for clauses (hypothesis, clause, invariant, etc). Let's talk briefly about that."),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"Goals vs clauses:")," ",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"The role of ",(0,l.kt)("inlineCode",{parentName:"li"},"\u2200")," in goals and clauses is different.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Proving $\\forall X. G$ requiers proving that ",(0,l.kt)("inlineCode",{parentName:"li"},"G")," is true for any value of ",(0,l.kt)("inlineCode",{parentName:"li"},"X")," (i.e., for a placeholder ",(0,l.kt)("inlineCode",{parentName:"li"},"(! X)"),", in our setup)."),(0,l.kt)("li",{parentName:"ul"},"In contrast, if you know $\\forall X. G$ as an axiom, it means that you can give ",(0,l.kt)("inlineCode",{parentName:"li"},"X")," any value ",(0,l.kt)("inlineCode",{parentName:"li"},"X1")," you want."))),(0,l.kt)("li",{parentName:"ul"},'Clauses have a limited structure between that keeps the solver tractable. The idea is that they are always "ways to prove a single predicate" true; we don\'t allow a clause like ',(0,l.kt)("inlineCode",{parentName:"li"},"(|| (A B))"),' as a clause, since that would mean "A or B is true but you don\'t know which". That would then be a second way to prove an ',(0,l.kt)("inlineCode",{parentName:"li"},"||")," goal like ",(0,l.kt)("inlineCode",{parentName:"li"},"(|| ...)")," and introduce lots of complications (we got enough already, thanks)."))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"Hypotheses vs clauses vs invariants:"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"These distinctions are used to express and capture implied bounds. We'll defer a detailed analysis until the section below, but briefly:",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},'"Hypotheses" are where-clauses that are assumed to be true in this section of the code.'),(0,l.kt)("li",{parentName:"ul"},'"Clauses" are global rules that are always true (derived, e.g., from an impl).'),(0,l.kt)("li",{parentName:"ul"},'"Invariants" express implied bounds (e.g., supertrait relationships like "if ',(0,l.kt)("inlineCode",{parentName:"li"},"T: Eq"),", then ",(0,l.kt)("inlineCode",{parentName:"li"},"T: PartialEq"),'").')))))),(0,l.kt)("h3",{id:"solver"},"Solver"),(0,l.kt)("p",null,"Putting all this together, the types layer currently includes a relatively simple solver called ",(0,l.kt)("inlineCode",{parentName:"p"},"cosld-solve"),". This is referencing the classic ",(0,l.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/SLD_resolution"},"SLD Resolution Algorithm")," that powers prolog, although the version of it that we've implemented is extended in two ways:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"It covers Hereditary Harrop predicates using the ",(0,l.kt)("a",{parentName:"li",href:"https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.107.2510&rep=rep1&type=pdf"},"techniques described by Gopalan Nadathur"),"."),(0,l.kt)("li",{parentName:"ul"},"It is coinductive as ",(0,l.kt)("a",{parentName:"li",href:"https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.102.9618&rep=rep1&type=pdf"},"described by Luke Simon et al.")," -- this means it permits cycles, roughly speaking.")),(0,l.kt)("p",null,'In terms of chalk solvers, it is "similar" to slg, but much simpler in its structure (it doesn\'t do any caching). '),(0,l.kt)("p",null,"All those fancy words aside, it's really quite simple. It's defined via induction rules, which PLT Redex lets us write in a natural style. The definition begins like so:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scheme"},"(define-judgment-form formality-ty\n  #:mode (prove I I I O)\n  #:contract (prove Env Predicates_stack Goal EnvSubstitution)\n")),(0,l.kt)("p",null,"This says that we are trying to prove something written as ",(0,l.kt)("inlineCode",{parentName:"p"},"(prove Env Predciates Goal EnvSubstitution)"),", where the first three are 'inputs' and the final name is an 'output' (the input vs output distinction is often left implicit in Prolog and other languages). The idea is that we will prove that ",(0,l.kt)("inlineCode",{parentName:"p"},"Goal")," is true in some environment ",(0,l.kt)("inlineCode",{parentName:"p"},"Env"),"; the environment contains our hypotheses and clauses, as well as information about the variables in scope. The ",(0,l.kt)("inlineCode",{parentName:"p"},"Predicates")," list is the stack of things we are solving, it's used to detect cycles. The ",(0,l.kt)("inlineCode",{parentName:"p"},"EnvSubstitution")," is the ",(0,l.kt)("em",{parentName:"p"},"output"),", it is a modified environment paired with a substitution that potentially gives new values to inference variables found in ",(0,l.kt)("inlineCode",{parentName:"p"},"Goal"),"."),(0,l.kt)("p",null,"Here is a simple rule. It defines the way we prove ",(0,l.kt)("inlineCode",{parentName:"p"},"||")," (",(0,l.kt)("a",{parentName:"p",href:"https://github.com/nikomatsakis/a-mir-formality/blob/main/src/ty/cosld-solve/prove.rkt#L62-L65"},"source"),'). The notation is as follows. The stuff "above the line" are the conditions that have to be proven; the thing "under the line" is the conclusion that we can draw.'),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scheme"},'  [(prove Env Predicates_stack Goal_1 EnvSubstitution_out)\n   ------------------------------------------------------- "prove-any"\n   (prove Env Predicates_stack (|| (Goal_0 ... Goal_1 Goal_2 ...)) EnvSubstitution_out)\n   ]\n')),(0,l.kt)("p",null,"This rule says:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Given some goal ",(0,l.kt)("inlineCode",{parentName:"li"},"(|| (Goal_0 ... Goal_1 Goal_2 ...))")," where ",(0,l.kt)("inlineCode",{parentName:"li"},"Goal_1")," is found somewhere in that list...",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"if we can prove ",(0,l.kt)("inlineCode",{parentName:"li"},"Goal_1")," to be true, then the ",(0,l.kt)("inlineCode",{parentName:"li"},"||")," goal is true.")))),(0,l.kt)("p",null,"Or read another way:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"If we can prove ",(0,l.kt)("inlineCode",{parentName:"li"},"Goal_1")," to be true, then we can prove ",(0,l.kt)("inlineCode",{parentName:"li"},"(|| Goals)")," to be true so long as ",(0,l.kt)("inlineCode",{parentName:"li"},"Goal_1")," is somewhere in ",(0,l.kt)("inlineCode",{parentName:"li"},"Goals"),".")),(0,l.kt)("p",null,'It shows you a bit of the power of PLT Redex (and Racket\'s pattern matching), as well. We are able to write the rule in a "non-deterministic" way -- saying, "pick any goal from the list" and prove it. Redex will search all the possibilities.'),(0,l.kt)("h2",{id:"a-closer-look-at-formality-decl"},"A closer look at formality-decl"),(0,l.kt)("p",null,"Now that we've surveyed the type layer, let's look at the declaration layer. It begins by declaring an \"extended\" language ",(0,l.kt)("inlineCode",{parentName:"p"},"formality-decl")," that adds new stuff to ",(0,l.kt)("inlineCode",{parentName:"p"},"formality-ty")," (",(0,l.kt)("a",{parentName:"p",href:"https://github.com/nikomatsakis/a-mir-formality/blob/47eceea34b5f56a55d781acc73dca86c996b15c5/src/decl/grammar.rkt#L5"},"source"),"):"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scheme"},"(define-extended-language formality-decl formality-ty ...)\n")),(0,l.kt)("p",null,"For example, a set of crates looks like this (",(0,l.kt)("a",{parentName:"p",href:"https://github.com/nikomatsakis/a-mir-formality/blob/47eceea34b5f56a55d781acc73dca86c996b15c5/src/decl/grammar.rkt#L7-L10"},"source"),"):"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scheme"}," (CrateDecls := (CrateDecl ...))\n  (CrateDecl := (CrateId CrateContents))\n  (CrateContents := (crate (CrateItemDecl ...)))\n  (CrateItemDecl := AdtDecl TraitDecl TraitImplDecl)\n")),(0,l.kt)("p",null,"Basically a list of items like ",(0,l.kt)("inlineCode",{parentName:"p"},"(a (crate (item1 item2 item3)))")," where ",(0,l.kt)("inlineCode",{parentName:"p"},"item{1,2,3}")," are either structs/enums (",(0,l.kt)("inlineCode",{parentName:"p"},"AdtDecl"),"), traits (",(0,l.kt)("inlineCode",{parentName:"p"},"TraitDecl"),"), or impls (",(0,l.kt)("inlineCode",{parentName:"p"},"TraitImplDecl"),")."),(0,l.kt)("h3",{id:"declaring-traits-in-formalitydecl"},"Declaring traits in ",(0,l.kt)("inlineCode",{parentName:"h3"},"FormalityDecl")),(0,l.kt)("p",null,"Let's look more closely at one of those kinds of items. A trait declaration looks like this (",(0,l.kt)("a",{parentName:"p",href:"https://github.com/nikomatsakis/a-mir-formality/blob/47eceea34b5f56a55d781acc73dca86c996b15c5/src/decl/grammar.rkt#L26-L27"},"source"),"):"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scheme"},"  (TraitDecl := (TraitId TraitContents))\n  (TraitContents := (trait KindedVarIds WhereClauses TraitItems))\n  ...\n  (WhereClauses := (WhereClause ...))\n  (WhereClause :=\n               (\u2200 KindedVarIds WhereClause)\n               (is-implemented TraitRef)\n               )\n")),(0,l.kt)("p",null,"Here:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"TraitId")," is the name of the trait"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"KindedVarIds")," is a list of generic parameters like ",(0,l.kt)("inlineCode",{parentName:"li"},"((TyVar Self) (TyVar T))"),". Note that the ",(0,l.kt)("inlineCode",{parentName:"li"},"Self")," parameter is made explicit. "),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"WhereClauses")," is a list of where-clauses, which are currently just ",(0,l.kt)("inlineCode",{parentName:"li"},"T: Foo")," trait references (though potentially higher-ranked)."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"TraitItems")," are the contents of the trait, currently not used for anything.")),(0,l.kt)("p",null,"So the following Rust trait"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},"trait Foo<T: Ord>: Bar { }\n")),(0,l.kt)("p",null,"would be represented as"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scheme"},"(Foo (trait ; KindedVarIds -- the generics:\n            ((type Self) (type T))\n            ; where clauses, including supertraits:\n            ((T : Ord()) (Self : Bar()))\n            ; trait items, empty list:\n            ()\n            ))\n")),(0,l.kt)("h3",{id:"lowering-crate-items-to-clauses"},"Lowering crate items to clauses"),(0,l.kt)("p",null,"The next part of ",(0,l.kt)("inlineCode",{parentName:"p"},"formality-decl")," is the metafunction ",(0,l.kt)("inlineCode",{parentName:"p"},"env-with-crate-decls")," (",(0,l.kt)("a",{parentName:"p",href:"https://github.com/nikomatsakis/a-mir-formality/blob/47eceea34b5f56a55d781acc73dca86c996b15c5/src/decl/decl-to-clause.rkt#L20-L23"},"source"),"):"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scheme"},"(define-metafunction formality-decl\n  ;; Add the clauses/hypothesis from multiple crates\n  ;; into the environment, where CrateId names the current crate.\n  env-with-crate-decls : Env CrateDecls CrateId -> Env\n  ; ...\n  )\n")),(0,l.kt)("p",null,"What this does is to convert ",(0,l.kt)("em",{parentName:"p"},"Rust declarations")," into the ",(0,l.kt)("em",{parentName:"p"},"environment")," from the type layer. Note that it takes:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"a base environment ",(0,l.kt)("inlineCode",{parentName:"li"},"Env")," (typically just the constant ",(0,l.kt)("inlineCode",{parentName:"li"},"EmptyEnv"),")"),(0,l.kt)("li",{parentName:"ul"},"a set of crates ",(0,l.kt)("inlineCode",{parentName:"li"},"CrateDecls")," (this is meant to include the imports)"),(0,l.kt)("li",{parentName:"ul"},"the id of the current crate ",(0,l.kt)("inlineCode",{parentName:"li"},"CrateId"),". This is because the set of rules we generate for a particular item can be different depending on whether we are compiling the crate where it was declared or some other crate (consider e.g. ",(0,l.kt)("inlineCode",{parentName:"li"},"#[non_exhaustive]"),").")),(0,l.kt)("h3",{id:"generating-the-clauses-for-a-single-crate-item"},"Generating the clauses for a single crate item"),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"env-with-crate-decls")," function just iterates over all the items in all the crates and ultimately invokes this helper function, ",(0,l.kt)("inlineCode",{parentName:"p"},"crate-item-decl-rules")," (",(0,l.kt)("a",{parentName:"p",href:"https://github.com/nikomatsakis/a-mir-formality/blob/47eceea34b5f56a55d781acc73dca86c996b15c5/src/decl/decl-to-clause.rkt#L57-L63"},"source"),"):"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scheme"},"(define-metafunction formality-decl\n  ;; Given a crate item, return a tuple of:\n  ;;\n  ;; * The clauses that hold in all crates due to this item\n  ;; * The invariants that hold in all crates due to this item\n  ;; * The invariants that hold only in the crate that declared this item\n  crate-item-decl-rules : CrateDecls CrateItemDecl -> (Clauses Invariants Invariants)\n")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"crate-item-decl-rules")," takes "),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"the full set of crates ",(0,l.kt)("inlineCode",{parentName:"li"},"CrateDecls")," and"),(0,l.kt)("li",{parentName:"ul"},"the declaration of a single item ",(0,l.kt)("inlineCode",{parentName:"li"},"CrateItemDecl"))),(0,l.kt)("p",null,"and it returns a 3-tuple. As the comment says, this contains both clauses (rules that can be used to derive true facts) along with two sets of invariants. We'll cover the invariants later."),(0,l.kt)("p",null,'Metafunctions are basically a gigantic match statement. They consist of a series of clauses, each of which begins with a "pattern match" against the arguments. '),(0,l.kt)("p",null,"To see how it works, let's look at the case for an ",(0,l.kt)("inlineCode",{parentName:"p"},"impl")," from that section. To begin with, here is the comment explaining what we aim to do:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scheme"}," [;; For an trait impl declared in the crate C, like the following:\n   ;;\n   ;;     impl<'a, T> Foo<'a, T> for i32 where T: Ord { }\n   ;;\n   ;; We consider `has-impl` to hold if (a) all inputs are well formed and (b) where\n   ;; clauses are satisfied:\n   ;;\n   ;;     (\u2200 ((lifetime 'a) (type T))\n   ;;         (has-impl (Foo (i32 'a u32))) :-\n   ;;             (well-formed (type i32))\n   ;;             (well-formed (type i32))\n   ;;             (is-implemented (Ord T)))\n")),(0,l.kt)("p",null,"The actual code for this (",(0,l.kt)("a",{parentName:"p",href:"https://github.com/nikomatsakis/a-mir-formality/blob/47eceea34b5f56a55d781acc73dca86c996b15c5/src/decl/decl-to-clause.rkt#L141-L166"},"source"),") begins by matching the item that we are generating rules for:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scheme"},"   (crate-item-decl-rules CrateDecls (impl KindedVarIds_impl TraitRef WhereClauses_impl ImplItems))\n")),(0,l.kt)("p",null,"The next line is the final result. The function this is part of  -- this says we will produce one global clause"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scheme"},"   ((Clause) () ())\n")),(0,l.kt)("p",null,"This final result is allowed to refer to variables defined on the following lines, shown below. A ",(0,l.kt)("inlineCode",{parentName:"p"},"(where/error <pattern> <value>)")," clause is effectively just ",(0,l.kt)("inlineCode",{parentName:"p"},"let <pattern> = <value>"),", in Rust terms; the ",(0,l.kt)("inlineCode",{parentName:"p"},"/error"),' part means "if this pattern doesn\'t match, generate an error". You can also write ',(0,l.kt)("inlineCode",{parentName:"p"},"(where <pattern> <value>)"),", but that means that if the pattern doesn't match, the metafunction should to see if the next rule works."),(0,l.kt)("p",null,"The impl code begins by pattern matching against the ",(0,l.kt)("inlineCode",{parentName:"p"},"TraitRef")," that the impl is implementing (in the example from the comment, that would be ",(0,l.kt)("inlineCode",{parentName:"p"},"(Foo (i32 'a T))"),"). We extract out the ",(0,l.kt)("inlineCode",{parentName:"p"},"TraitId")," and the self type ",(0,l.kt)("inlineCode",{parentName:"p"},"Parameter_trait"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scheme"},"   (where/error (TraitId (Parameter_trait ...)) TraitRef)\n")),(0,l.kt)("p",null,"Next we look up the definition of the trait itself to find out its generics, using a helper function ",(0,l.kt)("inlineCode",{parentName:"p"},"item-with-id"),". This matches and extracts out the parameter kinds (lifetimes vs types, in this code):"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scheme"},"   (where/error (trait KindedVarIds_trait _ _) (item-with-id CrateDecls TraitId))\n   (where/error ((ParameterKind_trait _) ...) KindedVarIds_trait)\n")),(0,l.kt)("p",null,"Next we convert the where clauses (e,g, ",(0,l.kt)("inlineCode",{parentName:"p"},"T: Ord"),") into goals, using a helper function ",(0,l.kt)("inlineCode",{parentName:"p"},"where-clauses-to-goals")," (described below):"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scheme"},"   (where/error (Goal_wc ...) (where-clauses-to-goals WhereClauses_impl))\n")),(0,l.kt)("p",null,"Finally we can generate that variable ",(0,l.kt)("inlineCode",{parentName:"p"},"Clause")," that was referenced in the final result. Note that we use the ",(0,l.kt)("inlineCode",{parentName:"p"},"..."),' notation to "flatten" together the list of goals from the where-clauses (',(0,l.kt)("inlineCode",{parentName:"p"},"Goal_wc ..."),") and ",(0,l.kt)("inlineCode",{parentName:"p"},"well-formed"),"-ness goals that we must prove (i.e., to use the impl, we must show that its input types are well-formed):"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scheme"},"   (where/error Clause (\u2200 KindedVarIds_impl\n                               (implies\n                                ((well-formed (ParameterKind_trait Parameter_trait)) ...\n                                 Goal_wc ...\n                                 )\n                                (has-impl TraitRef))))\n   ]\n")),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"where-clause-to-goal")," helper is fairly simple. Here is the source, I'll leave puzzling it out as an exercise to the reader (",(0,l.kt)("a",{parentName:"p",href:"https://github.com/nikomatsakis/a-mir-formality/blob/47eceea34b5f56a55d781acc73dca86c996b15c5/src/decl/decl-to-clause.rkt#L197-L211"},"source"),"):"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scheme"},"(define-metafunction formality-decl\n  ;; Convert a where clause `W` into a goal that proves `W` is true.\n  where-clause-to-goal : WhereClause -> Goal\n\n  ((where-clause-to-goal (is-implemented TraitRef))\n   (is-implemented TraitRef)\n   )\n\n  ((where-clause-to-goal (\u2200 KindedVarIds WhereClause))\n   (\u2200 KindedVarIds Goal)\n   (where/error Goal (where-clause-to-goal WhereClause))\n   )\n\n  ; FIXME: Support lifetimes, projections\n  )\n")),(0,l.kt)("h3",{id:"generating-the-ok-goals-for-a-crate"},'Generating the "ok goals" for a crate'),(0,l.kt)("p",null,'In addition to "clauses", there is also a function ',(0,l.kt)("inlineCode",{parentName:"p"},"crate-ok-goal")," that generate goals for each crate item in a given crate (",(0,l.kt)("a",{parentName:"p",href:"https://github.com/nikomatsakis/a-mir-formality/blob/47eceea34b5f56a55d781acc73dca86c996b15c5/src/decl/decl-ok.rkt#L7-L11"},"source"),"):"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scheme"},'(define-metafunction formality-decl\n  ;; Given a set of crates and the decl for the current crate,\n  ;; generate the goal that proves all declarations in the current crate are\n  ;; "ok". Other crates are assumed to be "ok".\n  crate-ok-goal : CrateDecls CrateDecl -> Goal\n')),(0,l.kt)("p",null,'The idea is that the crate is "ok" (i.e., passes the type check) if these goals are satisfied. For the declarations layer, these goals correspond roughly to rustc\'s ',(0,l.kt)("inlineCode",{parentName:"p"},"wfcheck"),". Here is the rule for impls (",(0,l.kt)("a",{parentName:"p",href:"https://github.com/nikomatsakis/a-mir-formality/blob/47eceea34b5f56a55d781acc73dca86c996b15c5/src/decl/decl-ok.rkt#L59-L71"},"source"),"):"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scheme"},"  [;; For a trait impl declared in the crate C, like the following:\n   ;;\n   ;;     impl<'a, T> Foo<'a, T> for u32 { }\n   ;;\n   ;; we require that the trait is implemented.\n   (crate-item-ok-goal _ (impl KindedVarIds_impl TraitRef WhereClauses_impl ImplItems))\n   (\u2200 KindedVarIds_impl\n           (implies ((well-formed KindedVarId_impl) ... WhereClause_impl ...)\n                    (&& ((is-implemented TraitRef)))))\n\n   (where/error (KindedVarId_impl ...) KindedVarIds_impl)\n   (where/error (WhereClause_impl ...) WhereClauses_impl)\n   ]\n  )\n")),(0,l.kt)("p",null,"In short, an impl is well-formed if the trait is implemented. We'll look at the definition of ",(0,l.kt)("inlineCode",{parentName:"p"},"is-implemented")," in more detail in ",(0,l.kt)("a",{parentName:"p",href:"#Case-study-Implied-bounds-and-perfect-derive"},"the next section"),", but for now it suffices to say that a trait is implemented if (a) it has an impl and (b) all of its where-clauses are satisfied. Since we know there is an impl (we're checking it right now!) this is equivalent to saying \"all of the trait's where clauses are satisfied\"."),(0,l.kt)("h2",{id:"case-study-implied-bounds-and-perfect-derive"},"Case study: Implied bounds and perfect derive"),(0,l.kt)("p",null,'The current code doesn\'t really model Rust as it is today. It actually models Rust extended with support for two new features, "implied bounds" and "perfect derive":'),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"Implied bounds:")," Given ",(0,l.kt)("inlineCode",{parentName:"li"},"struct Foo<T: Ord>"),", can ",(0,l.kt)("inlineCode",{parentName:"li"},"impl<T> Foo<T> { ... }")," just know that ",(0,l.kt)("inlineCode",{parentName:"li"},"T: Ord"),"?",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"(We actually have implied bounds today, but they are limited to supertraits (e.g., ",(0,l.kt)("inlineCode",{parentName:"li"},"T: Eq => T: PartialEq"),"), so maybe a better way to describe implied bounds would be ",(0,l.kt)("em",{parentName:"li"},"expanded implied bounds"),".)"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"Perfect derive:")," Given ",(0,l.kt)("inlineCode",{parentName:"li"},"#[derive(Clone)] struct Foo<T> { x: Rc<T> }"),', we "just know" that ',(0,l.kt)("inlineCode",{parentName:"li"},"impl<T> Clone for Foo<T>")," works, and that ",(0,l.kt)("inlineCode",{parentName:"li"},"T: Clone")," is not necessary?",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"The idea is that ",(0,l.kt)("inlineCode",{parentName:"li"},"derive")," would generate ",(0,l.kt)("inlineCode",{parentName:"li"},"impl<T> Clone for Foo<T> where Rc<T>: Clone"),". Seems simple, right?"),(0,l.kt)("li",{parentName:"ul"},"The trick is that we have to extend all trait matching to work like auto-traits does, and accept cycles. Consider deriving clone on",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"struct List<T> { value: Rc<T>, next: Option<Rc<List<T>>> }")),(0,l.kt)("li",{parentName:"ul"},"here you would get ",(0,l.kt)("inlineCode",{parentName:"li"},"impl<T> Clone for List<T> where Rc<T>: Clone, Option<Rc<List<T>>>: Clone")," -- if you try that today, you'll find it is a cycle error."))),(0,l.kt)("li",{parentName:"ul"},'We are going to refer to this "accept cycles" as coinductive; it\'s basically the ',(0,l.kt)("a",{parentName:"li",href:"https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.102.9618&rep=rep1&type=pdf"},"co-LP formulation by Luke Simon et al.")," that I referred to earlier.")))),(0,l.kt)("p",null,"These two features are a bit tricky to integrate because accepting cycles, if you're not careful, can easily lead you into assuming implied bounds that are not true. The classic example is this:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},"trait Copy { }\ntrait Magic: Copy { }\n")),(0,l.kt)("p",null,"Clearly, given these traits, we know that ",(0,l.kt)("inlineCode",{parentName:"p"},"T: Magic => T: Copy"),", right? But what about if someone writes this rather tautological impl:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},"impl<T: Magic> Magic for T { }\n")),(0,l.kt)("p",null,"If we're not careful, we can use this impl to show that every type implements ",(0,l.kt)("inlineCode",{parentName:"p"},"Magic")," -- and yet there is no ",(0,l.kt)("inlineCode",{parentName:"p"},"impl Copy")," anywhere. Something is off!"),(0,l.kt)("p",null,"The solution to that is based on the scheme that ",(0,l.kt)("a",{parentName:"p",href:"https://github.com/scalexm"},"scalexm"),' invented for Chalk; I\'ve tweaked it somewhat by integrating it a bit more deeply into the "core logic", which simplifies the predicates that we need. I find I like this formulation better, and it allows us to simplify a few other things too.'),(0,l.kt)("h3",{id:"distinguish-has-impl-and-is-implemented"},"Distinguish ",(0,l.kt)("inlineCode",{parentName:"h3"},"has-impl")," and ",(0,l.kt)("inlineCode",{parentName:"h3"},"is-implemented")),(0,l.kt)("p",null,"The first key part of the system is to distinguish ",(0,l.kt)("em",{parentName:"p"},"having an impl")," (",(0,l.kt)("inlineCode",{parentName:"p"},"has-impl"),") from ",(0,l.kt)("em",{parentName:"p"},"being implemented")," (",(0,l.kt)("inlineCode",{parentName:"p"},"is-implemented"),"). The former says that the user wrote an impl. The latter says that all the requirements are met to implement the trait, including in particular that all of its where clauses (which includes the supertraits) are satisfied."),(0,l.kt)("p",null,"Using the code for impls we saw earlier, the ",(0,l.kt)("inlineCode",{parentName:"p"},"Magic")," impl would generate the following clause:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scheme"},"; forall<T> { is-implemented(T: Magic) => has-impl(T: Magic) }\n(\u2200 ((type T)) \n        (implies ((is-implemented (Magic (T))))\n                 (has-impl (Magic (T)))))\n")),(0,l.kt)("p",null,"To actually prove ",(0,l.kt)("inlineCode",{parentName:"p"},"is-implemented(T: Magic)"),", This clause has to be combined with the clauses generated by the trait declarations (",(0,l.kt)("a",{parentName:"p",href:"https://github.com/nikomatsakis/a-mir-formality/blob/47eceea34b5f56a55d781acc73dca86c996b15c5/src/decl/decl-to-clause.rkt#L95-L118"},"source"),"). For the ",(0,l.kt)("inlineCode",{parentName:"p"},"Copy")," trait, which has no where clauses, this clause is very simple. To be implemented, the impl must exist, and the type must be well-formed:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scheme"},"; forall<T> { (\n;               has-impl(T: Copy), \n;               well-formed(T),\n;             ) => is-implemented(T: Copy) }\n(\u2200 ((type T))\n        (implies ((has-impl (Copy (T)))\n                  (well-formed (type (T))))\n                 (is-implemented (Copy (T)))))\n")),(0,l.kt)("p",null,"For ",(0,l.kt)("inlineCode",{parentName:"p"},"Magic"),", the rule includes the where clause that ",(0,l.kt)("inlineCode",{parentName:"p"},"T: Copy"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-schheme"},"; forall<T> { (\n;               has-impl(T: Magic), \n;               well-formed(T),\n;               is-implemented(T: Copy),\n;             ) => is-implemented(T: Magic) }\n(\u2200 ((type T))\n        (implies ((has-impl (Magic (T)))\n                  (well-formed (type (T)))\n                  (is-implemented (Copy (T))))\n                 (is-implemented (Magic (T)))))\n")),(0,l.kt)("p",null,"Now we start to see how this works -- if I want to call a function with a ",(0,l.kt)("inlineCode",{parentName:"p"},"T: Magic")," where clause, like this..."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},"fn make_the_magic_happen<T: Magic>(t: T) {\n    let u = t;\n    drop((t, u)); // both t, u are valid\n}\n")),(0,l.kt)("p",null,"...it is not enough to show that ",(0,l.kt)("inlineCode",{parentName:"p"},"has-impl")," is satisfied, I also have to prove that ",(0,l.kt)("inlineCode",{parentName:"p"},"T: Copy"),". To do that, I have to show that ",(0,l.kt)("inlineCode",{parentName:"p"},"has-impl(T: Copy)"),", and I can't do that."),(0,l.kt)("h3",{id:"but-wait-implied-bounds"},"But wait, implied bounds?"),(0,l.kt)("p",null,"Actually though, the above is not sufficient to solve the problem. That's because we haven't added in implied bounds yet! The ",(0,l.kt)("em",{parentName:"p"},"naive")," version of implied bounds is that we want to add in a rule like so:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"is-implemented(T: Magic) => is-implemented(T: Copy)\n")),(0,l.kt)("p",null,"i.e., if I know that ",(0,l.kt)("inlineCode",{parentName:"p"},"T: Magic"),", I also know that ",(0,l.kt)("inlineCode",{parentName:"p"},"T: Copy"),". But if we literally added that clause, it would be unsound, at least in a coinductive setting. Why is that? Say I want to prove that ",(0,l.kt)("inlineCode",{parentName:"p"},"String: Copy"),"..."),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"is-implemented(String: Copy)"),"? Well, that's true if...",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"is-implemented(String: Magic)"),"? Well, that's true if...",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"has-impl(String: Magic)"),"? Well, that's true if...",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"is-implemented(String: Magic)")," -- and that's on the stack, so that's ok!"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"well-formed(String)")," -- yep"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"is-implemented(String: Copy)")," -- well, that's on the stack, so that's ok!")))))),(0,l.kt)("p",null,"The traditional solution so this sort of problem is to impose some kind of limits on the impls people can write so they must be \"productive\". It's a bit tricky to define what productivity means, but intuitively it means \"not tautological\". The challenge is that the various schemes I've seen for showing productivity don't accept impls like the ones that perfect derive would create, so they wouldn't really work for us. The solution in the impl works a different way."),(0,l.kt)("p",null,'The co-LP formulation acccepts any cycle as valid, so it\'s very easy to create these kind of "tautological rules". Now, if the user actually ',(0,l.kt)("em",{parentName:"p"},"wrote")," those impls, I don't see that as a problem. It's ok to have mutually dependent impls, all we want to know basically is \"when I call a method, there will be some impl to go to\" (see example below). But it's not good if it's unsound. =)"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},"trait Foo {\n    fn foo(&self);\n}\n\ntrait Bar {\n    fn bar(&self);\n}\n\nimpl<T: Bar> Foo for T {\n    fn foo(&self) {\n        if something() { self.bar() }\n    }\n}\n\nimpl<T: Foo> Bar for T {\n    fn bar(&self) {\n        if something() { self.foo() }\n    }\n}\n")),(0,l.kt)("h3",{id:"enter-invariants"},"Enter: invariants"),(0,l.kt)("p",null,"The insight is that it's not ok to use implied bounds out of thin air. You only want to use them for where-clauses that you have in scope. In this way, they are categorically different from program clauses, which always hold. I've decided to refer to implied bounds as ",(0,l.kt)("em",{parentName:"p"},"invariants"),' -- the idea is that they are things which "must be true if the program is valid". So for our program we would have one ',(0,l.kt)("strong",{parentName:"p"},"invariant"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"forall<T> { is-implemented(T: Magic) => is-implemented(T: Copy) }\n")),(0,l.kt)("p",null,"To express this a bit more formally, let ",(0,l.kt)("inlineCode",{parentName:"p"},"F"),' be the set of all "facts" we can generate from the clauses alone (a "fact" here is just a predicate that refers to some concrete types and thing)s. Because there are an infinite set of types, the set of facts is also infinite, but that\'s ok. In our example, given the rules we\'ve seen so far (but ignoring the implied bound), we can show that ',(0,l.kt)("inlineCode",{parentName:"p"},"has-impl(i32: Magic)")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"has-impl(u32: Magic)")," easily enough. We don't have a ",(0,l.kt)("inlineCode",{parentName:"p"},"has-impl(i32: Copy)")," fact, though, and because of that we also can't have a ",(0,l.kt)("inlineCode",{parentName:"p"},"is-implemented(i32: Copy)")," fact. Given this set of facts ",(0,l.kt)("inlineCode",{parentName:"p"},"F"),", then we ought to be able to prove each invariant ",(0,l.kt)("inlineCode",{parentName:"p"},"I"),", or something is broken in our type rules. In our example, the invariant ",(0,l.kt)("inlineCode",{parentName:"p"},"forall<T> { is-implemented(T: Magic) => is-implemented(T: Copy) }")," does in fact hold, because there are no ",(0,l.kt)("inlineCode",{parentName:"p"},"is-implemented(T: Magic)")," facts."),(0,l.kt)("h3",{id:"integrating-invariants-into-the-solver"},"Integrating invariants into the solver"),(0,l.kt)("p",null,"The solver is able to make use of invariants to generate proofs, but only in a limited way. Whereas we can always use a program clause, we can only apply invariants to the ",(0,l.kt)("em",{parentName:"p"},"hypotheses")," that are in scope -- a ",(0,l.kt)("em",{parentName:"p"},"hypotheses")," is some where-clause that we are assuming to be true. The idea here is that the caller must have proven that hypothesis to be a ",(0,l.kt)("em",{parentName:"p"},"fact")," -- if they did so, then unless our type rules are broken, the invariant holds, which means that any facts we can derive with the invariants are also true."),(0,l.kt)("p",null,"This in turn implies that the seemingly tautological impl of ",(0,l.kt)("inlineCode",{parentName:"p"},"Magic")," is actually ",(0,l.kt)("strong",{parentName:"p"},"legal"),'! Recall the "ok goals" we saw before, that are used to decide which declarations are legal. The "ok" goal for the magic impl looks like this:'),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scheme"},"(\u2200 ((type T))\n        (implies ((is-implemented (Magic (T))))\n                 (is-implemented (Magic (T)))))\n")),(0,l.kt)("p",null,'Basically, "if we assume that ',(0,l.kt)("inlineCode",{parentName:"p"},"T: Magic")," is implemented, then we can show that ",(0,l.kt)("inlineCode",{parentName:"p"},"T: Magic")," is implemented\". Well, that's obviously true."),(0,l.kt)("p",null,"OK, so the impl is legal, but what about this function ",(0,l.kt)("inlineCode",{parentName:"p"},"make_the_magic_happen"),"?"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},"fn make_the_magic_happen<T: Magic>(t: T) {\n    let u = t;\n    drop((t, u)); // both t, u are valid\n}\n")),(0,l.kt)("p",null,"We don't currently have type-checking logic in formality but, if we did, type-checking this function would require copying ",(0,l.kt)("inlineCode",{parentName:"p"},"t")," and hence proving that:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"forall<T> {\n    is-implemented(T: Magic) => is-implemented(T: Copy)\n}\n")),(0,l.kt)("p",null,"Here the ",(0,l.kt)("inlineCode",{parentName:"p"},"is-implemented(T: Magic) => ...")," comes from the where-clauses on the function. To solve this, the solver puts ",(0,l.kt)("inlineCode",{parentName:"p"},"is-implemented(T: Magic)"),' into the environment as a hypothesis using the "prove-implies" rule (',(0,l.kt)("a",{parentName:"p",href:"https://github.com/nikomatsakis/a-mir-formality/blob/47eceea34b5f56a55d781acc73dca86c996b15c5/src/ty/cosld-solve/prove.rkt#L67-L71"},"source"),"):"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scheme"},'  [(where Env_1 (env-with-hypotheses Env Hypotheses))\n   (prove Env_1 Predicates_stack Goal EnvSubstitution_out)\n   -------------------------------------------------------- "prove-implies"\n   (prove Env Predicates_stack (implies Hypotheses Goal) (reset Env () EnvSubstitution_out))\n   ]\n')),(0,l.kt)("p",null,'Next it can apply the "prove-hypothesis-imply" rule (',(0,l.kt)("a",{parentName:"p",href:"https://github.com/nikomatsakis/a-mir-formality/blob/47eceea34b5f56a55d781acc73dca86c996b15c5/src/ty/cosld-solve/prove.rkt#L41-L45"},"source"),"):"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scheme"},'  [(where #f (in? Predicate Predicates_stack))\n   (Hypotheses-imply Env () Predicate EnvSubstitution_out)\n   --------------- "prove-hypotheses-imply"\n   (prove Env Predicates_stack Predicate EnvSubstitution_out)\n   ]\n')),(0,l.kt)("p",null,"This rule usess ",(0,l.kt)("a",{parentName:"p",href:"https://github.com/nikomatsakis/a-mir-formality/blob/47eceea34b5f56a55d781acc73dca86c996b15c5/src/ty/cosld-solve/hypothesize.rkt#L9-L11"},(0,l.kt)("inlineCode",{parentName:"a"},"Hypotheses-imply")),", another typing judgment which determines whether ",(0,l.kt)("inlineCode",{parentName:"p"},"Predicate")," is either ",(0,l.kt)("em",{parentName:"p"},"directly")," in the environment as a hypothesis ",(0,l.kt)("strong",{parentName:"p"},"or can be derived via an invariant"),". This last part is what we need here! The only hypothesis in the environment is ",(0,l.kt)("inlineCode",{parentName:"p"},"is-implemented(T: Magic)"),", but we can use the invariant"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"is-implemented(T: Magic) => is-implemented(T: Copy)\n")),(0,l.kt)("p",null,"to expand that to ",(0,l.kt)("inlineCode",{parentName:"p"},"is-implemented(T: Copy)"),", so we are happy."),(0,l.kt)("h3",{id:"wait-so-is-this-sound"},"Wait, so is this sound?"),(0,l.kt)("p",null,"But accepting this impl and this function this doesn't mean we have an unsound program -- the question is, who is going to ",(0,l.kt)("em",{parentName:"p"},"call")," that function, and with what type? And this is where the errors come in. Consider this ",(0,l.kt)("inlineCode",{parentName:"p"},"main")," function:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'fn main() {\n    make_the_magic_happen("Die, cruel world, die!".to_string());\n}\n')),(0,l.kt)("p",null,"For this program to type-check, we must prove the where-clauses on ",(0,l.kt)("inlineCode",{parentName:"p"},"make_the_magic_happen"),", which means proving"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"is-implemented(String: Magic)\n")),(0,l.kt)("p",null,"But in this case, there are no hypotheses in the environment, so we can't make use of the invariants. We have to use the program clause, it requires also showing that ",(0,l.kt)("inlineCode",{parentName:"p"},"is-implemented(String: Copy)")," which in turn means showing ",(0,l.kt)("inlineCode",{parentName:"p"},"has-impl(String: Copy)"),", and we cannot do that."),(0,l.kt)("p",null,'Thinking a bit more abstractly, no matter what where clauses we have on various functions, we will "bottom out" in a ',(0,l.kt)("inlineCode",{parentName:"p"},"main")," function somewhere, and ",(0,l.kt)("inlineCode",{parentName:"p"},"main")," has no where clauses. Therefore, if our program relies on ",(0,l.kt)("inlineCode",{parentName:"p"},"is-implemented(i32: Magic)"),", that must be provable in an environment with no hypotheses. Put another way, ",(0,l.kt)("inlineCode",{parentName:"p"},"is-implemented(i32: Magic)"),' must be a member of that infinite set of facts that we described earlier, the ones which categorize "everything that is true in this program". But we already argued that this set does not include ',(0,l.kt)("inlineCode",{parentName:"p"},"is-implemented(i32: Magic)"),", because the only way to get such a fact is to use the program clause, and the program clause requires that ",(0,l.kt)("inlineCode",{parentName:"p"},"has-impl(i32: Copy)"),", which is not true."),(0,l.kt)("h3",{id:"productivity-again"},"Productivity again?"),(0,l.kt)("p",null,'xxx -- didn\'t get time to to finish this, but I think that you can frame the previous two sections in terms of the typical "productivity" rules. There is a nice thesis I\'ve been slowly working through on this. The TL;DR is something like this: "we accept all cycles but require that for any proof of ',(0,l.kt)("inlineCode",{parentName:"p"},"is-implemented(T: Foo)"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"has-impl(T: Foo)")," must appear somewhere in the cycle\", but that's not quite stating it right."),(0,l.kt)("h2",{id:"future-directions"},"Future directions"),(0,l.kt)("p",null,"Here are some of the next steps I've been thinking about and we could discuss:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"There are some fixes to how ",(0,l.kt)("inlineCode",{parentName:"li"},"Hypothesize-implies"),' works that I want to make (I think it should be "bottom-up", not "top-down" as it is today, if that makes sense -- basically adopt the elaboration strategy from)'),(0,l.kt)("li",{parentName:"ul"},"Sketch out the MIR type-checker"),(0,l.kt)("li",{parentName:"ul"},"Integrate higher-ranked types and regions, polonius, etc -- I've been reading up on subtyping systems and I think I have some ideas for a fresh approach here"),(0,l.kt)("li",{parentName:"ul"},'Implement the "recursive solver" as a metafunction',(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},'it is useful to be able to compare the "cosld-solver", which I believe is sound+complete, against ours, which (I hope) is merely sound'))),(0,l.kt)("li",{parentName:"ul"},"Extend rustc with ",(0,l.kt)("inlineCode",{parentName:"li"},"-Zformality")," to allow it to generate formality programs"),(0,l.kt)("li",{parentName:"ul"},'Use PLT redex to fuzz the existing solver and test the "invariant logic"')),(0,l.kt)("h1",{id:"nikos-faq"},"Niko's FAQ"),(0,l.kt)("h2",{id:"if-this-is-a-complete-model-isnt-that-just-an-implementation"},"If this is a complete model, isn't that just an implementation?"),(0,l.kt)("p",null,"Not really. It leaves out a ton of stuff:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"diagnostics"),(0,l.kt)("li",{parentName:"ul"},"low-level ABI details"),(0,l.kt)("li",{parentName:"ul"},"parser and concrete rust syntax"),(0,l.kt)("li",{parentName:"ul"},"running C code and FFI (though you can imagine translating C code to equivalent unsafe Rust, which would be supported to some extent)"),(0,l.kt)("li",{parentName:"ul"},"platform specific things, interactions with the operating system")),(0,l.kt)("p",null,"Currently, it's focusing on MIR and back, which means we can exclude a lot of things"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"name resolution"),(0,l.kt)("li",{parentName:"ul"},"layout (we can take struct layouts as inputs)"),(0,l.kt)("li",{parentName:"ul"})),(0,l.kt)("h1",{id:"questions"},"Questions"),(0,l.kt)("h2",{id:"are-there-any-fundamental-differences-to-chalk-so-far"},"Are there any fundamental differences to Chalk, so far?"),(0,l.kt)("p",null,"nikomatsakis: Yes. Chalk does not have the concept of invariants and handles implied bounds in a different way (",(0,l.kt)("inlineCode",{parentName:"p"},"FromEnv")," goals). Chalk also has one structural setup that has to be ported to formality -- it generates program clauses \"on demand\". This is required because actually the set of program clauses for a Rust program is potentially infinite (think of e.g. auto traits). I've been debating the best way to model this with PLT Redex and in particular whether it's important to preserve the various layers I've shown here, it might be easier if we merged everything into one."),(0,l.kt)("h2",{id:"is-this-an-ideal-rust-model-or-a-practical-one"},'Is this an "ideal" Rust model, or a "practical" one?'),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Current Rust semantics, or the one we want")),(0,l.kt)("p",null,'nikomatsakis: You\'re asking the right question, and it\'s something I wanted to discuss. Right now it\'s the "ideal" model in the sense that I am using it to show how some extensions to Rust would work, but I think it\'s important that it be the "practical" one too. It\'s not hard to disable the implied bounds (actually, limit them to supertraits) and remove support for cycles. What\'s a bit more interesting, and I\'m not sure about it, is the best way to have "feature gates" so that we can show the "diff required" to support a new feature. '),(0,l.kt)("h2",{id:"is-it-practical-to-try-to-develop-chalk-alongside-ie-update-chalks-rules-as-a-mir-formality-is-updated"},"Is it practical to try to develop Chalk alongside? I.e. update Chalk's rules as a-mir-formality is updated?"),(0,l.kt)("p",null,'nikomatsakis: I think so, and I think we should. This is partly why Formality\'s structure intentionally mirrors Chalk (and it should eventually include the solver, so that we can show "these are things the compiler should be able to prove" versus "these are things that are provable"). The idea is that we can prototype and explore more quickly in this environment, but chalk would scale up to real programs (the PLT Redex solver is way too slow for that). Also, Chalk\'s structure would be more optimized for performance, for giving good error messages, for dealing with low-level ABI details, and all the other fun stuff that the model does NOT include.'),(0,l.kt)("h2",{id:"what-about-coq"},"What about Coq?"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"it seems that coq is the most popular at POPL etc. How well do you think the framework you're using will integrate into other PL tools/efforts?")),(0,l.kt)("p",null,'nikomatsakis: As you can see, the notation is quite high-level, so if nothing else I think it would be easy to manually transcribe things. But I would assume people have made efforts to "export" rules and things from PLT Redex to other formats.'),(0,l.kt)("h2",{id:"how-would-types-team-signoff-integrate-into-feature-process"},"How would types team signoff integrate into feature process?"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},'add a checkbox "types team signoff" for new language features'),(0,l.kt)("li",{parentName:"ul"},"open an issue on formality repository")),(0,l.kt)("h2",{id:"howwhere-does-coercion-fit-in"},"How/where does coercion fit in?"))}c.isMDXComponent=!0}}]);