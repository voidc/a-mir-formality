<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://nikomatsakis.github.io/a-mir-formality/a-mir-formality/blog</id>
    <title>a-mir-formality Blog</title>
    <updated>2022-05-12T00:00:00.000Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://nikomatsakis.github.io/a-mir-formality/a-mir-formality/blog"/>
    <subtitle>a-mir-formality Blog</subtitle>
    <icon>https://nikomatsakis.github.io/a-mir-formality/a-mir-formality/img/ferris.svg</icon>
    <entry>
        <title type="html"><![CDATA[a MIR Formality, goals and the reality]]></title>
        <id>/2022/05/12/</id>
        <link href="https://nikomatsakis.github.io/a-mir-formality/a-mir-formality/blog/2022/05/12/"/>
        <updated>2022-05-12T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[This is a document that was prepared for the 2022-03-18 types team deep dive (read the transcript from that meeting).]]></summary>
        <content type="html"><![CDATA[<p>This is a document that was prepared for the 2022-03-18 types team deep dive (<a href="https://rust-lang.zulipchat.com/#narrow/stream/144729-wg-traits/topic/deep.20dive.202022-03-18.3A.20intro.20to.20formality" target="_blank" rel="noopener noreferrer">read the transcript from that meeting</a>).</p><p>From <a href="https://github.com/nikomatsakis/a-mir-formality" target="_blank" rel="noopener noreferrer">the repository</a> (emphasis mine):</p><blockquote><p>This repository is an early-stage experimental project that aims to be a complete, authoritative formal model of the <a href="https://rustc-dev-guide.rust-lang.org/mir/index.html" target="_blank" rel="noopener noreferrer">Rust MIR</a>. <strong>Presuming these experiments bear fruit, the intention is to bring this model into Rust as an RFC and develop it as an official part of the language definition.</strong></p></blockquote><p>The goal of this document is to explain the high-level structure as well as giving a sense for the overall development roadmap I have in mind.</p><p>[ToC]</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="how-i-see-formality-being-used">How I see formality being used<a class="hash-link" href="#how-i-see-formality-being-used" title="Direct link to heading">​</a></h2><p>Formality will become the "primary source" for "what Rust means":</p><ul><li>When a new language feature is designed, one stage in the process will be formalizing that feature into formality. <ul><li>Currently, since formality focuses on MIR, this will only make sense for "core language features" like implied bounds or specialization. Eventually I'd like to extend formality to cover other areas like name resolution and Rust surface syntax.</li><li>This will help to uncover interactions between features.</li></ul></li><li>Formality can be fuzzed and checked against rustc, much as the <a href="https://www.amazon.science/publications/using-lightweight-formal-methods-to-validate-a-key-value-storage-node-in-amazon-s3" target="_blank" rel="noopener noreferrer">AWS S3 team does to check their code</a>.<ul><li>We can extend rustc to generate formality declarations.</li></ul></li><li>For the trait solver, formality will map quite closely to its overall structure, which allows us to experiment with new algorithms or structure and see their effects quickly.<ul><li>As an initial example, I plan to prototype a new approach for associated type normalization.</li></ul></li></ul><h2 class="anchor anchorWithStickyNavbar_mojV" id="why-a-new-repo-why-plt-redex">Why a new repo? Why PLT redex?<a class="hash-link" href="#why-a-new-repo-why-plt-redex" title="Direct link to heading">​</a></h2><p>I had originally hoped that chalk could serve as a kind of "executable semantics" for Rust. The idea was that the separation between "generating clauses" and "the solver" would allow us to specify how Rust works on a high-enough level that the code is nicely generic. Over time, though, I've become convinced that this approach won't scale. There is a lot of "incidental complexity" that is created by integrating chalk into rustc, as well as engineering for efficiency. Ultimately, I don't see chalk being sufficiently malleable for our purposes.</p><p>I chose to use PLT Redex because it's a really great tool for exploration. It allows you to write very high-level structures, execute them, and see what happens. I think it's sufficiently approachable that we can onboard contributors and grow the types team. I'm not sure the same is true of other alternatives. Plus I like it.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="formality-and-the-types-team">Formality and the types team<a class="hash-link" href="#formality-and-the-types-team" title="Direct link to heading">​</a></h2><p>I imagine formality being "owned and maintained" by the types team, like other rust-lang projects. </p><h2 class="anchor anchorWithStickyNavbar_mojV" id="layers-of-formality">Layers of formality<a class="hash-link" href="#layers-of-formality" title="Direct link to heading">​</a></h2><p>Formality is structured into several layers. These layers are meant to also map fairly closely onto chalk and the eventual Rust trait solver implementation. Ideally, one should be able to map back and forth between formality and the code with ease.</p><ul><li><strong>formality-ty:</strong> the "types" layer<ul><li>Defines Rust types and functions for equating/relating them.<ul><li>The representation is meant to cover all Rust types, but is optimized for extracting their "essential properties".</li></ul></li><li>Defines core logical predicates (<code>is-implemented(T: Trait)</code>, etc) and solvers.<ul><li>But doesn't define what they <em>mean</em> -- i.e., the conditions in which they are true.</li></ul></li></ul></li><li><strong>formality-decl:</strong> the "Rust declarations" layer<ul><li>Defines Rust "top-level items" and their semantics<ul><li>This includes crates, structs, traits, impls, but excludes function bodies.</li></ul></li><li>Semantics are defined by converting Rust items into predicates<ul><li>e.g., <code>impl&lt;T: Eq&gt; Eq for Vec&lt;T&gt;</code> becomes a "program clause" (axiom) like <code>forall&lt;T&gt; { is-implemented(T: Eq) =&gt; has-impl(Vec&lt;T: Eq&gt;) }</code> (the distinction between <code>has-impl</code> and <code>is-implemented</code> is covered below).</li></ul></li><li>Defines the well-formedness checks for those items<ul><li>e.g., <code>struct Foo { f1: T1 }</code> is well-formed if </li></ul></li></ul></li><li><strong>formality-mir:</strong> the "type system for MIR" layer<ul><li>Defines MIR and rules for its type checker (corresponds roughly to the MIR borrow checker + polonius).</li><li>Caveat: I've sketched this out, but nothing more.</li></ul></li><li><strong>formality-mir-op:</strong> the "operational semantics for MIR" layer<ul><li>Extends the above level with an operational semantics. Basically equivalent to miri.</li><li>Caveat: I haven't even sketched this out yet.</li></ul></li></ul><h2 class="anchor anchorWithStickyNavbar_mojV" id="a-closer-look-at-formality-ty">A closer look at formality-ty<a class="hash-link" href="#a-closer-look-at-formality-ty" title="Direct link to heading">​</a></h2><p>Let's take a closer look at the formality-ty layer. </p><h3 class="anchor anchorWithStickyNavbar_mojV" id="defining-rust-types">Defining Rust types<a class="hash-link" href="#defining-rust-types" title="Direct link to heading">​</a></h3><p>The current definition of types looks like this (<a href="https://github.com/nikomatsakis/a-mir-formality/blob/47eceea34b5f56a55d781acc73dca86c996b15c5/src/ty/grammar.rkt#L25-L37" target="_blank" rel="noopener noreferrer">source</a>):</p><div class="language-scheme codeBlockContainer_MPoW theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_B9tL"><pre tabindex="0" class="prism-code language-scheme codeBlock__0OG thin-scrollbar"><code class="codeBlockLines_gEuF"><span class="token-line" style="color:#393A34"><span class="token plain">(define-language formality-ty</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  (Ty :=</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      (TyApply TyName Parameters) ; Application type</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      VarId                       ; Bound or existential (inference) variable</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      (! VarId)                   ; Universal (placeholder) variable</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  (TyName :=</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          AdtId           ; enum/struct/union</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          TraitId         ; trait</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          AssociatedTy    ; Associated type</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          ScalarId        ; Something like i32, u32, etc</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          (ref MaybeMut)  ; `&amp;mut` or `&amp;`, expects a lifetime + type parameter</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          (tuple number)  ; tuple of given arity</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   (ScalarId := i8 u8 i16 u16 i32 u32 i64 u64 i128 u128 bool)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   (AssociatedTy := (TraitId AssociatedTyId))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   (Parameters := (Parameter ...))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   (Parameter := Ty Lt)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   ((AdtId VarId TraitId AssociatedTyId AnyId) := variable-not-otherwise-mentioned)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">)</span><br></span></code></pre><div class="buttonGroup_hRr1"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>As you can see, it's woefully incomplete, but it should give you some idea for the level of abstraction we are shooting for and also how PLT Redex works. The idea here is that a type is either a variable, a placeholder that represents a generic type, or an "application" of a type name to some parameters. Let's see some examples:</p><ul><li>A generic type like <code>T</code> could either be <code>T</code> or <code>(! T)</code>:<ul><li><code>T</code> is used when the generic has yet to be substituted, e.g., as part of a declaration.</li><li><code>(! T)</code> is used as a placeholder to "any type <code>T</code>".</li></ul></li><li>A type like <code>Vec&lt;T&gt;</code> in Rust would be represented therefore as:<ul><li><code>(TyApply Vec (T))</code>, in a declaration; or,</li><li><code>(TyApply Vec ((! T)))</code> when checking it.</li></ul></li><li>A scalar type like <code>i32</code> is represented as <code>(TyApply i32 ())</code>.</li></ul><p>As I said, this defintion of types is woefully incomplete. I expect it to eventually include:</p><ul><li>"alias types" like associated types and type aliases</li><li>"existential" types like <code>dyn</code></li><li>"forall" quantifies to cover <code>for&lt;'a&gt; ...</code></li><li>"function" types <code>fn(A1...An) -&gt; R</code></li><li>"implication" types <code>where(...) T</code>-- these don't exist in Rust yet =)</li></ul><p>You can also see that the definition of types is aligned to highlight their "essential" characteristics and not necessarily for convenience elsewhere. Almost every Rust type, for example, boils down to <em>some</em> kind of "application" (it's likely that we can even represent <code>fn</code> types this way).</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="type-unification">Type unification<a class="hash-link" href="#type-unification" title="Direct link to heading">​</a></h3><p>A key part of the type layer is that it includes <em>type unification</em>. That is, it defines the rules for making types equal. This will eventually have to be extended to cover subtyping (more on that a bit later) so that we can properly handle variance.</p><p>Unification is done via a "metafunction", which just means a function that operates on terms (versus a function in the Rust program being analyzed):</p><div class="language-scheme codeBlockContainer_MPoW theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_B9tL"><pre tabindex="0" class="prism-code language-scheme codeBlock__0OG thin-scrollbar"><code class="codeBlockLines_gEuF"><span class="token-line" style="color:#393A34"><span class="token plain">(define-metafunction formality-ty</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  most-general-unifier : Env TermPairs -&gt; EnvSubstitution or Error</span><br></span></code></pre><div class="buttonGroup_hRr1"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>This function takes an environment <code>Env</code> and a list of pairs of terms that should be equated and gives back either:</p><ul><li>a new environment and substitution from inference variables to values that will make the two terms syntactically equal; or,</li><li>the term <code>Error</code>, if they cannot be unified.</li></ul><p>The unifier is a bit smarter than the traditional unification in that it knows about <em>universes</em> and so can handle "forall" proofs and things (that's what is found in the environment). This is the same as chalk and rustc. </p><p>I won't cover the details but I'll just give an example. This is actually modified from a unit test from the code (<a href="https://github.com/nikomatsakis/a-mir-formality/blob/47eceea34b5f56a55d781acc73dca86c996b15c5/src/ty/unify.rkt#L254-L269" target="_blank" rel="noopener noreferrer">source</a>). Invoking <code>most-general-unifier</code> like so:</p><div class="language-scheme codeBlockContainer_MPoW theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_B9tL"><pre tabindex="0" class="prism-code language-scheme codeBlock__0OG thin-scrollbar"><code class="codeBlockLines_gEuF"><span class="token-line" style="color:#393A34"><span class="token plain">(most-general-unifier Env_2 ((A X)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                             (X (TyApply Vec (Y)))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                             (Y (TyApply i32 ()))))</span><br></span></code></pre><div class="buttonGroup_hRr1"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>corresponds to saying that <code>[A = X, X = Vec&lt;Y&gt;, Y = i32]</code> must all be true, where <code>A</code>, <code>X</code> and <code>Y</code> are inference variables. The resulting output is a substitution that maps <code>A</code>, <code>X</code> and <code>Y</code> to the following values:</p><ul><li><code>A -&gt; Vec&lt;i32&gt;</code></li><li><code>X -&gt; Vec&lt;i32&gt;</code></li><li><code>Y -&gt; i32</code></li></ul><h3 class="anchor anchorWithStickyNavbar_mojV" id="predicates">Predicates<a class="hash-link" href="#predicates" title="Direct link to heading">​</a></h3><p>Formality-ty also defines the core predicates used to define Rust semantics. The current definition is as follows (<a href="https://github.com/nikomatsakis/a-mir-formality/blob/47eceea34b5f56a55d781acc73dca86c996b15c5/src/ty/grammar.rkt#L121-L130" target="_blank" rel="noopener noreferrer">source</a>):</p><div class="language-scheme codeBlockContainer_MPoW theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_B9tL"><pre tabindex="0" class="prism-code language-scheme codeBlock__0OG thin-scrollbar"><code class="codeBlockLines_gEuF"><span class="token-line" style="color:#393A34"><span class="token plain">  (Predicate :=</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             ; `TraitRef` is (fully) implemented.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             (is-implemented TraitRef)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             ; an impl exists for `TraitRef`; this *by itself* doesn't mean</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             ; that `TraitRef` is implemented, as the supertraits may not</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             ; have impls.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             (has-impl TraitRef)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             ; the given type or lifetime is well-formed.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             (well-formed (ParameterKind Parameter))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             )</span><br></span></code></pre><div class="buttonGroup_hRr1"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>These core predicates are then used to define a richer vocabulary of goals (things that can be proven) and various kinds of "clauses" (things that are assumed to be true, axioms) (<a href="https://github.com/nikomatsakis/a-mir-formality/blob/47eceea34b5f56a55d781acc73dca86c996b15c5/src/ty/grammar.rkt#L136-L143" target="_blank" rel="noopener noreferrer">source</a>):</p><div class="language-scheme codeBlockContainer_MPoW theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_B9tL"><pre tabindex="0" class="prism-code language-scheme codeBlock__0OG thin-scrollbar"><code class="codeBlockLines_gEuF"><span class="token-line" style="color:#393A34"><span class="token plain">  (Goals = (Goal ...))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  (Goal :=</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Predicate</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        (Equate Term Term)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        (&amp;&amp; Goals)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        (|| Goals)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        (implies Hypotheses Goal)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        (Quantifier KindedVarIds Goal)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ((Hypotheses Clauses Invariants) := (Clause ...))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ((Hypothesis Clause Invariant) :=</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                 Predicate</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                 (implies Goals Predicate)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                 (∀ KindedVarIds Clause)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                 )</span><br></span></code></pre><div class="buttonGroup_hRr1"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Importantly, the <em>types layer</em> defines a solver that gives semantics to all the "meta" parts of goals and clauses -- e.g., it defines what it means to prove <code>(&amp;&amp; (G1 G2))</code> (prove both <code>G1</code> and <code>G2</code>, duh). But it doesn't have any rules for what it means to prove the <em>core</em> predicates true -- so it could never prove <code>(is-implemented (Debug ((! T))))</code>. Those rules all come from the declaration layer and are given to the types layer as part of the "environment".</p><p>You might be curious about the distinction between goal and clause and why there are so many names for clauses (hypothesis, clause, invariant, etc). Let's talk briefly about that.</p><ul><li><strong>Goals vs clauses:</strong> <ul><li>The role of <code>∀</code> in goals and clauses is different.<ul><li>Proving $\forall X. G$ requiers proving that <code>G</code> is true for any value of <code>X</code> (i.e., for a placeholder <code>(! X)</code>, in our setup).</li><li>In contrast, if you know $\forall X. G$ as an axiom, it means that you can give <code>X</code> any value <code>X1</code> you want.</li></ul></li><li>Clauses have a limited structure between that keeps the solver tractable. The idea is that they are always "ways to prove a single predicate" true; we don't allow a clause like <code>(|| (A B))</code> as a clause, since that would mean "A or B is true but you don't know which". That would then be a second way to prove an <code>||</code> goal like <code>(|| ...)</code> and introduce lots of complications (we got enough already, thanks).</li></ul></li><li><strong>Hypotheses vs clauses vs invariants:</strong><ul><li>These distinctions are used to express and capture implied bounds. We'll defer a detailed analysis until the section below, but briefly:<ul><li>"Hypotheses" are where-clauses that are assumed to be true in this section of the code.</li><li>"Clauses" are global rules that are always true (derived, e.g., from an impl).</li><li>"Invariants" express implied bounds (e.g., supertrait relationships like "if <code>T: Eq</code>, then <code>T: PartialEq</code>").</li></ul></li></ul></li></ul><h3 class="anchor anchorWithStickyNavbar_mojV" id="solver">Solver<a class="hash-link" href="#solver" title="Direct link to heading">​</a></h3><p>Putting all this together, the types layer currently includes a relatively simple solver called <code>cosld-solve</code>. This is referencing the classic <a href="https://en.wikipedia.org/wiki/SLD_resolution" target="_blank" rel="noopener noreferrer">SLD Resolution Algorithm</a> that powers prolog, although the version of it that we've implemented is extended in two ways:</p><ul><li>It covers Hereditary Harrop predicates using the <a href="https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.107.2510&amp;rep=rep1&amp;type=pdf" target="_blank" rel="noopener noreferrer">techniques described by Gopalan Nadathur</a>.</li><li>It is coinductive as <a href="https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.102.9618&amp;rep=rep1&amp;type=pdf" target="_blank" rel="noopener noreferrer">described by Luke Simon et al.</a> -- this means it permits cycles, roughly speaking.</li></ul><p>In terms of chalk solvers, it is "similar" to slg, but much simpler in its structure (it doesn't do any caching). </p><p>All those fancy words aside, it's really quite simple. It's defined via induction rules, which PLT Redex lets us write in a natural style. The definition begins like so:</p><div class="language-scheme codeBlockContainer_MPoW theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_B9tL"><pre tabindex="0" class="prism-code language-scheme codeBlock__0OG thin-scrollbar"><code class="codeBlockLines_gEuF"><span class="token-line" style="color:#393A34"><span class="token plain">(define-judgment-form formality-ty</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  #:mode (prove I I I O)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  #:contract (prove Env Predicates_stack Goal EnvSubstitution)</span><br></span></code></pre><div class="buttonGroup_hRr1"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>This says that we are trying to prove something written as <code>(prove Env Predciates Goal EnvSubstitution)</code>, where the first three are 'inputs' and the final name is an 'output' (the input vs output distinction is often left implicit in Prolog and other languages). The idea is that we will prove that <code>Goal</code> is true in some environment <code>Env</code>; the environment contains our hypotheses and clauses, as well as information about the variables in scope. The <code>Predicates</code> list is the stack of things we are solving, it's used to detect cycles. The <code>EnvSubstitution</code> is the <em>output</em>, it is a modified environment paired with a substitution that potentially gives new values to inference variables found in <code>Goal</code>.</p><p>Here is a simple rule. It defines the way we prove <code>||</code> (<a href="https://github.com/nikomatsakis/a-mir-formality/blob/main/src/ty/cosld-solve/prove.rkt#L62-L65" target="_blank" rel="noopener noreferrer">source</a>). The notation is as follows. The stuff "above the line" are the conditions that have to be proven; the thing "under the line" is the conclusion that we can draw.</p><div class="language-scheme codeBlockContainer_MPoW theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_B9tL"><pre tabindex="0" class="prism-code language-scheme codeBlock__0OG thin-scrollbar"><code class="codeBlockLines_gEuF"><span class="token-line" style="color:#393A34"><span class="token plain">  [(prove Env Predicates_stack Goal_1 EnvSubstitution_out)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   ------------------------------------------------------- "prove-any"</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   (prove Env Predicates_stack (|| (Goal_0 ... Goal_1 Goal_2 ...)) EnvSubstitution_out)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   ]</span><br></span></code></pre><div class="buttonGroup_hRr1"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>This rule says:</p><ul><li>Given some goal <code>(|| (Goal_0 ... Goal_1 Goal_2 ...))</code> where <code>Goal_1</code> is found somewhere in that list...<ul><li>if we can prove <code>Goal_1</code> to be true, then the <code>||</code> goal is true.</li></ul></li></ul><p>Or read another way:</p><ul><li>If we can prove <code>Goal_1</code> to be true, then we can prove <code>(|| Goals)</code> to be true so long as <code>Goal_1</code> is somewhere in <code>Goals</code>.</li></ul><p>It shows you a bit of the power of PLT Redex (and Racket's pattern matching), as well. We are able to write the rule in a "non-deterministic" way -- saying, "pick any goal from the list" and prove it. Redex will search all the possibilities.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="a-closer-look-at-formality-decl">A closer look at formality-decl<a class="hash-link" href="#a-closer-look-at-formality-decl" title="Direct link to heading">​</a></h2><p>Now that we've surveyed the type layer, let's look at the declaration layer. It begins by declaring an "extended" language <code>formality-decl</code> that adds new stuff to <code>formality-ty</code> (<a href="https://github.com/nikomatsakis/a-mir-formality/blob/47eceea34b5f56a55d781acc73dca86c996b15c5/src/decl/grammar.rkt#L5" target="_blank" rel="noopener noreferrer">source</a>):</p><div class="language-scheme codeBlockContainer_MPoW theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_B9tL"><pre tabindex="0" class="prism-code language-scheme codeBlock__0OG thin-scrollbar"><code class="codeBlockLines_gEuF"><span class="token-line" style="color:#393A34"><span class="token plain">(define-extended-language formality-decl formality-ty ...)</span><br></span></code></pre><div class="buttonGroup_hRr1"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>For example, a set of crates looks like this (<a href="https://github.com/nikomatsakis/a-mir-formality/blob/47eceea34b5f56a55d781acc73dca86c996b15c5/src/decl/grammar.rkt#L7-L10" target="_blank" rel="noopener noreferrer">source</a>):</p><div class="language-scheme codeBlockContainer_MPoW theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_B9tL"><pre tabindex="0" class="prism-code language-scheme codeBlock__0OG thin-scrollbar"><code class="codeBlockLines_gEuF"><span class="token-line" style="color:#393A34"><span class="token plain"> (CrateDecls := (CrateDecl ...))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  (CrateDecl := (CrateId CrateContents))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  (CrateContents := (crate (CrateItemDecl ...)))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  (CrateItemDecl := AdtDecl TraitDecl TraitImplDecl)</span><br></span></code></pre><div class="buttonGroup_hRr1"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Basically a list of items like <code>(a (crate (item1 item2 item3)))</code> where <code>item{1,2,3}</code> are either structs/enums (<code>AdtDecl</code>), traits (<code>TraitDecl</code>), or impls (<code>TraitImplDecl</code>).</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="declaring-traits-in-formalitydecl">Declaring traits in <code>FormalityDecl</code><a class="hash-link" href="#declaring-traits-in-formalitydecl" title="Direct link to heading">​</a></h3><p>Let's look more closely at one of those kinds of items. A trait declaration looks like this (<a href="https://github.com/nikomatsakis/a-mir-formality/blob/47eceea34b5f56a55d781acc73dca86c996b15c5/src/decl/grammar.rkt#L26-L27" target="_blank" rel="noopener noreferrer">source</a>):</p><div class="language-scheme codeBlockContainer_MPoW theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_B9tL"><pre tabindex="0" class="prism-code language-scheme codeBlock__0OG thin-scrollbar"><code class="codeBlockLines_gEuF"><span class="token-line" style="color:#393A34"><span class="token plain">  (TraitDecl := (TraitId TraitContents))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  (TraitContents := (trait KindedVarIds WhereClauses TraitItems))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  (WhereClauses := (WhereClause ...))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  (WhereClause :=</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               (∀ KindedVarIds WhereClause)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               (is-implemented TraitRef)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               )</span><br></span></code></pre><div class="buttonGroup_hRr1"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Here:</p><ul><li><code>TraitId</code> is the name of the trait</li><li><code>KindedVarIds</code> is a list of generic parameters like <code>((TyVar Self) (TyVar T))</code>. Note that the <code>Self</code> parameter is made explicit. </li><li><code>WhereClauses</code> is a list of where-clauses, which are currently just <code>T: Foo</code> trait references (though potentially higher-ranked).</li><li><code>TraitItems</code> are the contents of the trait, currently not used for anything.</li></ul><p>So the following Rust trait</p><div class="language-rust codeBlockContainer_MPoW theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_B9tL"><pre tabindex="0" class="prism-code language-rust codeBlock__0OG thin-scrollbar"><code class="codeBlockLines_gEuF"><span class="token-line" style="color:#393A34"><span class="token plain">trait Foo&lt;T: Ord&gt;: Bar { }</span><br></span></code></pre><div class="buttonGroup_hRr1"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>would be represented as</p><div class="language-scheme codeBlockContainer_MPoW theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_B9tL"><pre tabindex="0" class="prism-code language-scheme codeBlock__0OG thin-scrollbar"><code class="codeBlockLines_gEuF"><span class="token-line" style="color:#393A34"><span class="token plain">(Foo (trait ; KindedVarIds -- the generics:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ((type Self) (type T))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ; where clauses, including supertraits:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ((T : Ord()) (Self : Bar()))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ; trait items, empty list:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ))</span><br></span></code></pre><div class="buttonGroup_hRr1"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_mojV" id="lowering-crate-items-to-clauses">Lowering crate items to clauses<a class="hash-link" href="#lowering-crate-items-to-clauses" title="Direct link to heading">​</a></h3><p>The next part of <code>formality-decl</code> is the metafunction <code>env-with-crate-decls</code> (<a href="https://github.com/nikomatsakis/a-mir-formality/blob/47eceea34b5f56a55d781acc73dca86c996b15c5/src/decl/decl-to-clause.rkt#L20-L23" target="_blank" rel="noopener noreferrer">source</a>):</p><div class="language-scheme codeBlockContainer_MPoW theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_B9tL"><pre tabindex="0" class="prism-code language-scheme codeBlock__0OG thin-scrollbar"><code class="codeBlockLines_gEuF"><span class="token-line" style="color:#393A34"><span class="token plain">(define-metafunction formality-decl</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ;; Add the clauses/hypothesis from multiple crates</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ;; into the environment, where CrateId names the current crate.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  env-with-crate-decls : Env CrateDecls CrateId -&gt; Env</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ; ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  )</span><br></span></code></pre><div class="buttonGroup_hRr1"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>What this does is to convert <em>Rust declarations</em> into the <em>environment</em> from the type layer. Note that it takes:</p><ul><li>a base environment <code>Env</code> (typically just the constant <code>EmptyEnv</code>)</li><li>a set of crates <code>CrateDecls</code> (this is meant to include the imports)</li><li>the id of the current crate <code>CrateId</code>. This is because the set of rules we generate for a particular item can be different depending on whether we are compiling the crate where it was declared or some other crate (consider e.g. <code>#[non_exhaustive]</code>).</li></ul><h3 class="anchor anchorWithStickyNavbar_mojV" id="generating-the-clauses-for-a-single-crate-item">Generating the clauses for a single crate item<a class="hash-link" href="#generating-the-clauses-for-a-single-crate-item" title="Direct link to heading">​</a></h3><p>The <code>env-with-crate-decls</code> function just iterates over all the items in all the crates and ultimately invokes this helper function, <code>crate-item-decl-rules</code> (<a href="https://github.com/nikomatsakis/a-mir-formality/blob/47eceea34b5f56a55d781acc73dca86c996b15c5/src/decl/decl-to-clause.rkt#L57-L63" target="_blank" rel="noopener noreferrer">source</a>):</p><div class="language-scheme codeBlockContainer_MPoW theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_B9tL"><pre tabindex="0" class="prism-code language-scheme codeBlock__0OG thin-scrollbar"><code class="codeBlockLines_gEuF"><span class="token-line" style="color:#393A34"><span class="token plain">(define-metafunction formality-decl</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ;; Given a crate item, return a tuple of:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ;; * The clauses that hold in all crates due to this item</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ;; * The invariants that hold in all crates due to this item</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ;; * The invariants that hold only in the crate that declared this item</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  crate-item-decl-rules : CrateDecls CrateItemDecl -&gt; (Clauses Invariants Invariants)</span><br></span></code></pre><div class="buttonGroup_hRr1"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><code>crate-item-decl-rules</code> takes </p><ul><li>the full set of crates <code>CrateDecls</code> and</li><li>the declaration of a single item <code>CrateItemDecl</code></li></ul><p>and it returns a 3-tuple. As the comment says, this contains both clauses (rules that can be used to derive true facts) along with two sets of invariants. We'll cover the invariants later.</p><p>Metafunctions are basically a gigantic match statement. They consist of a series of clauses, each of which begins with a "pattern match" against the arguments. </p><p>To see how it works, let's look at the case for an <code>impl</code> from that section. To begin with, here is the comment explaining what we aim to do:</p><div class="language-scheme codeBlockContainer_MPoW theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_B9tL"><pre tabindex="0" class="prism-code language-scheme codeBlock__0OG thin-scrollbar"><code class="codeBlockLines_gEuF"><span class="token-line" style="color:#393A34"><span class="token plain"> [;; For an trait impl declared in the crate C, like the following:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   ;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   ;;     impl&lt;'a, T&gt; Foo&lt;'a, T&gt; for i32 where T: Ord { }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   ;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   ;; We consider `has-impl` to hold if (a) all inputs are well formed and (b) where</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   ;; clauses are satisfied:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   ;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   ;;     (∀ ((lifetime 'a) (type T))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   ;;         (has-impl (Foo (i32 'a u32))) :-</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   ;;             (well-formed (type i32))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   ;;             (well-formed (type i32))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   ;;             (is-implemented (Ord T)))</span><br></span></code></pre><div class="buttonGroup_hRr1"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>The actual code for this (<a href="https://github.com/nikomatsakis/a-mir-formality/blob/47eceea34b5f56a55d781acc73dca86c996b15c5/src/decl/decl-to-clause.rkt#L141-L166" target="_blank" rel="noopener noreferrer">source</a>) begins by matching the item that we are generating rules for:</p><div class="language-scheme codeBlockContainer_MPoW theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_B9tL"><pre tabindex="0" class="prism-code language-scheme codeBlock__0OG thin-scrollbar"><code class="codeBlockLines_gEuF"><span class="token-line" style="color:#393A34"><span class="token plain">   (crate-item-decl-rules CrateDecls (impl KindedVarIds_impl TraitRef WhereClauses_impl ImplItems))</span><br></span></code></pre><div class="buttonGroup_hRr1"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>The next line is the final result. The function this is part of  -- this says we will produce one global clause</p><div class="language-scheme codeBlockContainer_MPoW theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_B9tL"><pre tabindex="0" class="prism-code language-scheme codeBlock__0OG thin-scrollbar"><code class="codeBlockLines_gEuF"><span class="token-line" style="color:#393A34"><span class="token plain">   ((Clause) () ())</span><br></span></code></pre><div class="buttonGroup_hRr1"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>This final result is allowed to refer to variables defined on the following lines, shown below. A <code>(where/error &lt;pattern&gt; &lt;value&gt;)</code> clause is effectively just <code>let &lt;pattern&gt; = &lt;value&gt;</code>, in Rust terms; the <code>/error</code> part means "if this pattern doesn't match, generate an error". You can also write <code>(where &lt;pattern&gt; &lt;value&gt;)</code>, but that means that if the pattern doesn't match, the metafunction should to see if the next rule works.</p><p>The impl code begins by pattern matching against the <code>TraitRef</code> that the impl is implementing (in the example from the comment, that would be <code>(Foo (i32 'a T))</code>). We extract out the <code>TraitId</code> and the self type <code>Parameter_trait</code>:</p><div class="language-scheme codeBlockContainer_MPoW theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_B9tL"><pre tabindex="0" class="prism-code language-scheme codeBlock__0OG thin-scrollbar"><code class="codeBlockLines_gEuF"><span class="token-line" style="color:#393A34"><span class="token plain">   (where/error (TraitId (Parameter_trait ...)) TraitRef)</span><br></span></code></pre><div class="buttonGroup_hRr1"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Next we look up the definition of the trait itself to find out its generics, using a helper function <code>item-with-id</code>. This matches and extracts out the parameter kinds (lifetimes vs types, in this code):</p><div class="language-scheme codeBlockContainer_MPoW theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_B9tL"><pre tabindex="0" class="prism-code language-scheme codeBlock__0OG thin-scrollbar"><code class="codeBlockLines_gEuF"><span class="token-line" style="color:#393A34"><span class="token plain">   (where/error (trait KindedVarIds_trait _ _) (item-with-id CrateDecls TraitId))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   (where/error ((ParameterKind_trait _) ...) KindedVarIds_trait)</span><br></span></code></pre><div class="buttonGroup_hRr1"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Next we convert the where clauses (e,g, <code>T: Ord</code>) into goals, using a helper function <code>where-clauses-to-goals</code> (described below):</p><div class="language-scheme codeBlockContainer_MPoW theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_B9tL"><pre tabindex="0" class="prism-code language-scheme codeBlock__0OG thin-scrollbar"><code class="codeBlockLines_gEuF"><span class="token-line" style="color:#393A34"><span class="token plain">   (where/error (Goal_wc ...) (where-clauses-to-goals WhereClauses_impl))</span><br></span></code></pre><div class="buttonGroup_hRr1"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Finally we can generate that variable <code>Clause</code> that was referenced in the final result. Note that we use the <code>...</code> notation to "flatten" together the list of goals from the where-clauses (<code>Goal_wc ...</code>) and <code>well-formed</code>-ness goals that we must prove (i.e., to use the impl, we must show that its input types are well-formed):</p><div class="language-scheme codeBlockContainer_MPoW theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_B9tL"><pre tabindex="0" class="prism-code language-scheme codeBlock__0OG thin-scrollbar"><code class="codeBlockLines_gEuF"><span class="token-line" style="color:#393A34"><span class="token plain">   (where/error Clause (∀ KindedVarIds_impl</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                               (implies</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                ((well-formed (ParameterKind_trait Parameter_trait)) ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                 Goal_wc ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                 )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                (has-impl TraitRef))))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   ]</span><br></span></code></pre><div class="buttonGroup_hRr1"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>The <code>where-clause-to-goal</code> helper is fairly simple. Here is the source, I'll leave puzzling it out as an exercise to the reader (<a href="https://github.com/nikomatsakis/a-mir-formality/blob/47eceea34b5f56a55d781acc73dca86c996b15c5/src/decl/decl-to-clause.rkt#L197-L211" target="_blank" rel="noopener noreferrer">source</a>):</p><div class="language-scheme codeBlockContainer_MPoW theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_B9tL"><pre tabindex="0" class="prism-code language-scheme codeBlock__0OG thin-scrollbar"><code class="codeBlockLines_gEuF"><span class="token-line" style="color:#393A34"><span class="token plain">(define-metafunction formality-decl</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ;; Convert a where clause `W` into a goal that proves `W` is true.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  where-clause-to-goal : WhereClause -&gt; Goal</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ((where-clause-to-goal (is-implemented TraitRef))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   (is-implemented TraitRef)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ((where-clause-to-goal (∀ KindedVarIds WhereClause))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   (∀ KindedVarIds Goal)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   (where/error Goal (where-clause-to-goal WhereClause))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ; FIXME: Support lifetimes, projections</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  )</span><br></span></code></pre><div class="buttonGroup_hRr1"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_mojV" id="generating-the-ok-goals-for-a-crate">Generating the "ok goals" for a crate<a class="hash-link" href="#generating-the-ok-goals-for-a-crate" title="Direct link to heading">​</a></h3><p>In addition to "clauses", there is also a function <code>crate-ok-goal</code> that generate goals for each crate item in a given crate (<a href="https://github.com/nikomatsakis/a-mir-formality/blob/47eceea34b5f56a55d781acc73dca86c996b15c5/src/decl/decl-ok.rkt#L7-L11" target="_blank" rel="noopener noreferrer">source</a>):</p><div class="language-scheme codeBlockContainer_MPoW theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_B9tL"><pre tabindex="0" class="prism-code language-scheme codeBlock__0OG thin-scrollbar"><code class="codeBlockLines_gEuF"><span class="token-line" style="color:#393A34"><span class="token plain">(define-metafunction formality-decl</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ;; Given a set of crates and the decl for the current crate,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ;; generate the goal that proves all declarations in the current crate are</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ;; "ok". Other crates are assumed to be "ok".</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  crate-ok-goal : CrateDecls CrateDecl -&gt; Goal</span><br></span></code></pre><div class="buttonGroup_hRr1"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>The idea is that the crate is "ok" (i.e., passes the type check) if these goals are satisfied. For the declarations layer, these goals correspond roughly to rustc's <code>wfcheck</code>. Here is the rule for impls (<a href="https://github.com/nikomatsakis/a-mir-formality/blob/47eceea34b5f56a55d781acc73dca86c996b15c5/src/decl/decl-ok.rkt#L59-L71" target="_blank" rel="noopener noreferrer">source</a>):</p><div class="language-scheme codeBlockContainer_MPoW theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_B9tL"><pre tabindex="0" class="prism-code language-scheme codeBlock__0OG thin-scrollbar"><code class="codeBlockLines_gEuF"><span class="token-line" style="color:#393A34"><span class="token plain">  [;; For a trait impl declared in the crate C, like the following:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   ;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   ;;     impl&lt;'a, T&gt; Foo&lt;'a, T&gt; for u32 { }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   ;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   ;; we require that the trait is implemented.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   (crate-item-ok-goal _ (impl KindedVarIds_impl TraitRef WhereClauses_impl ImplItems))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   (∀ KindedVarIds_impl</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">           (implies ((well-formed KindedVarId_impl) ... WhereClause_impl ...)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    (&amp;&amp; ((is-implemented TraitRef)))))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   (where/error (KindedVarId_impl ...) KindedVarIds_impl)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   (where/error (WhereClause_impl ...) WhereClauses_impl)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   ]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  )</span><br></span></code></pre><div class="buttonGroup_hRr1"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>In short, an impl is well-formed if the trait is implemented. We'll look at the definition of <code>is-implemented</code> in more detail in <a href="#Case-study-Implied-bounds-and-perfect-derive">the next section</a>, but for now it suffices to say that a trait is implemented if (a) it has an impl and (b) all of its where-clauses are satisfied. Since we know there is an impl (we're checking it right now!) this is equivalent to saying "all of the trait's where clauses are satisfied".</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="case-study-implied-bounds-and-perfect-derive">Case study: Implied bounds and perfect derive<a class="hash-link" href="#case-study-implied-bounds-and-perfect-derive" title="Direct link to heading">​</a></h2><p>The current code doesn't really model Rust as it is today. It actually models Rust extended with support for two new features, "implied bounds" and "perfect derive":</p><ul><li><strong>Implied bounds:</strong> Given <code>struct Foo&lt;T: Ord&gt;</code>, can <code>impl&lt;T&gt; Foo&lt;T&gt; { ... }</code> just know that <code>T: Ord</code>?<ul><li>(We actually have implied bounds today, but they are limited to supertraits (e.g., <code>T: Eq =&gt; T: PartialEq</code>), so maybe a better way to describe implied bounds would be <em>expanded implied bounds</em>.)</li></ul></li><li><strong>Perfect derive:</strong> Given <code>#[derive(Clone)] struct Foo&lt;T&gt; { x: Rc&lt;T&gt; }</code>, we "just know" that <code>impl&lt;T&gt; Clone for Foo&lt;T&gt;</code> works, and that <code>T: Clone</code> is not necessary?<ul><li>The idea is that <code>derive</code> would generate <code>impl&lt;T&gt; Clone for Foo&lt;T&gt; where Rc&lt;T&gt;: Clone</code>. Seems simple, right?</li><li>The trick is that we have to extend all trait matching to work like auto-traits does, and accept cycles. Consider deriving clone on<ul><li><code>struct List&lt;T&gt; { value: Rc&lt;T&gt;, next: Option&lt;Rc&lt;List&lt;T&gt;&gt;&gt; }</code></li><li>here you would get <code>impl&lt;T&gt; Clone for List&lt;T&gt; where Rc&lt;T&gt;: Clone, Option&lt;Rc&lt;List&lt;T&gt;&gt;&gt;: Clone</code> -- if you try that today, you'll find it is a cycle error.</li></ul></li><li>We are going to refer to this "accept cycles" as coinductive; it's basically the <a href="https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.102.9618&amp;rep=rep1&amp;type=pdf" target="_blank" rel="noopener noreferrer">co-LP formulation by Luke Simon et al.</a> that I referred to earlier.</li></ul></li></ul><p>These two features are a bit tricky to integrate because accepting cycles, if you're not careful, can easily lead you into assuming implied bounds that are not true. The classic example is this:</p><div class="language-rust codeBlockContainer_MPoW theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_B9tL"><pre tabindex="0" class="prism-code language-rust codeBlock__0OG thin-scrollbar"><code class="codeBlockLines_gEuF"><span class="token-line" style="color:#393A34"><span class="token plain">trait Copy { }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">trait Magic: Copy { }</span><br></span></code></pre><div class="buttonGroup_hRr1"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Clearly, given these traits, we know that <code>T: Magic =&gt; T: Copy</code>, right? But what about if someone writes this rather tautological impl:</p><div class="language-rust codeBlockContainer_MPoW theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_B9tL"><pre tabindex="0" class="prism-code language-rust codeBlock__0OG thin-scrollbar"><code class="codeBlockLines_gEuF"><span class="token-line" style="color:#393A34"><span class="token plain">impl&lt;T: Magic&gt; Magic for T { }</span><br></span></code></pre><div class="buttonGroup_hRr1"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>If we're not careful, we can use this impl to show that every type implements <code>Magic</code> -- and yet there is no <code>impl Copy</code> anywhere. Something is off!</p><p>The solution to that is based on the scheme that <a href="https://github.com/scalexm" target="_blank" rel="noopener noreferrer">scalexm</a> invented for Chalk; I've tweaked it somewhat by integrating it a bit more deeply into the "core logic", which simplifies the predicates that we need. I find I like this formulation better, and it allows us to simplify a few other things too.</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="distinguish-has-impl-and-is-implemented">Distinguish <code>has-impl</code> and <code>is-implemented</code><a class="hash-link" href="#distinguish-has-impl-and-is-implemented" title="Direct link to heading">​</a></h3><p>The first key part of the system is to distinguish <em>having an impl</em> (<code>has-impl</code>) from <em>being implemented</em> (<code>is-implemented</code>). The former says that the user wrote an impl. The latter says that all the requirements are met to implement the trait, including in particular that all of its where clauses (which includes the supertraits) are satisfied.</p><p>Using the code for impls we saw earlier, the <code>Magic</code> impl would generate the following clause:</p><div class="language-scheme codeBlockContainer_MPoW theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_B9tL"><pre tabindex="0" class="prism-code language-scheme codeBlock__0OG thin-scrollbar"><code class="codeBlockLines_gEuF"><span class="token-line" style="color:#393A34"><span class="token plain">; forall&lt;T&gt; { is-implemented(T: Magic) =&gt; has-impl(T: Magic) }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(∀ ((type T)) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        (implies ((is-implemented (Magic (T))))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 (has-impl (Magic (T)))))</span><br></span></code></pre><div class="buttonGroup_hRr1"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>To actually prove <code>is-implemented(T: Magic)</code>, This clause has to be combined with the clauses generated by the trait declarations (<a href="https://github.com/nikomatsakis/a-mir-formality/blob/47eceea34b5f56a55d781acc73dca86c996b15c5/src/decl/decl-to-clause.rkt#L95-L118" target="_blank" rel="noopener noreferrer">source</a>). For the <code>Copy</code> trait, which has no where clauses, this clause is very simple. To be implemented, the impl must exist, and the type must be well-formed:</p><div class="language-scheme codeBlockContainer_MPoW theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_B9tL"><pre tabindex="0" class="prism-code language-scheme codeBlock__0OG thin-scrollbar"><code class="codeBlockLines_gEuF"><span class="token-line" style="color:#393A34"><span class="token plain">; forall&lt;T&gt; { (</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;               has-impl(T: Copy), </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;               well-formed(T),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;             ) =&gt; is-implemented(T: Copy) }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(∀ ((type T))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        (implies ((has-impl (Copy (T)))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  (well-formed (type (T))))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 (is-implemented (Copy (T)))))</span><br></span></code></pre><div class="buttonGroup_hRr1"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>For <code>Magic</code>, the rule includes the where clause that <code>T: Copy</code>:</p><div class="language-schheme codeBlockContainer_MPoW theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_B9tL"><pre tabindex="0" class="prism-code language-schheme codeBlock__0OG thin-scrollbar"><code class="codeBlockLines_gEuF"><span class="token-line" style="color:#393A34"><span class="token plain">; forall&lt;T&gt; { (</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;               has-impl(T: Magic), </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;               well-formed(T),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;               is-implemented(T: Copy),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;             ) =&gt; is-implemented(T: Magic) }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(∀ ((type T))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        (implies ((has-impl (Magic (T)))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  (well-formed (type (T)))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  (is-implemented (Copy (T))))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 (is-implemented (Magic (T)))))</span><br></span></code></pre><div class="buttonGroup_hRr1"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Now we start to see how this works -- if I want to call a function with a <code>T: Magic</code> where clause, like this...</p><div class="language-rust codeBlockContainer_MPoW theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_B9tL"><pre tabindex="0" class="prism-code language-rust codeBlock__0OG thin-scrollbar"><code class="codeBlockLines_gEuF"><span class="token-line" style="color:#393A34"><span class="token plain">fn make_the_magic_happen&lt;T: Magic&gt;(t: T) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let u = t;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    drop((t, u)); // both t, u are valid</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_hRr1"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>...it is not enough to show that <code>has-impl</code> is satisfied, I also have to prove that <code>T: Copy</code>. To do that, I have to show that <code>has-impl(T: Copy)</code>, and I can't do that.</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="but-wait-implied-bounds">But wait, implied bounds?<a class="hash-link" href="#but-wait-implied-bounds" title="Direct link to heading">​</a></h3><p>Actually though, the above is not sufficient to solve the problem. That's because we haven't added in implied bounds yet! The <em>naive</em> version of implied bounds is that we want to add in a rule like so:</p><div class="codeBlockContainer_MPoW theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_B9tL"><pre tabindex="0" class="prism-code language-text codeBlock__0OG thin-scrollbar"><code class="codeBlockLines_gEuF"><span class="token-line" style="color:#393A34"><span class="token plain">is-implemented(T: Magic) =&gt; is-implemented(T: Copy)</span><br></span></code></pre><div class="buttonGroup_hRr1"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>i.e., if I know that <code>T: Magic</code>, I also know that <code>T: Copy</code>. But if we literally added that clause, it would be unsound, at least in a coinductive setting. Why is that? Say I want to prove that <code>String: Copy</code>...</p><ul><li><code>is-implemented(String: Copy)</code>? Well, that's true if...<ul><li><code>is-implemented(String: Magic)</code>? Well, that's true if...<ul><li><code>has-impl(String: Magic)</code>? Well, that's true if...<ul><li><code>is-implemented(String: Magic)</code> -- and that's on the stack, so that's ok!</li></ul></li><li><code>well-formed(String)</code> -- yep</li><li><code>is-implemented(String: Copy)</code> -- well, that's on the stack, so that's ok!</li></ul></li></ul></li></ul><p>The traditional solution so this sort of problem is to impose some kind of limits on the impls people can write so they must be "productive". It's a bit tricky to define what productivity means, but intuitively it means "not tautological". The challenge is that the various schemes I've seen for showing productivity don't accept impls like the ones that perfect derive would create, so they wouldn't really work for us. The solution in the impl works a different way.</p><p>The co-LP formulation acccepts any cycle as valid, so it's very easy to create these kind of "tautological rules". Now, if the user actually <em>wrote</em> those impls, I don't see that as a problem. It's ok to have mutually dependent impls, all we want to know basically is "when I call a method, there will be some impl to go to" (see example below). But it's not good if it's unsound. =)</p><div class="language-rust codeBlockContainer_MPoW theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_B9tL"><pre tabindex="0" class="prism-code language-rust codeBlock__0OG thin-scrollbar"><code class="codeBlockLines_gEuF"><span class="token-line" style="color:#393A34"><span class="token plain">trait Foo {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn foo(&amp;self);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">trait Bar {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn bar(&amp;self);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl&lt;T: Bar&gt; Foo for T {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn foo(&amp;self) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if something() { self.bar() }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl&lt;T: Foo&gt; Bar for T {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn bar(&amp;self) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if something() { self.foo() }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_hRr1"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_mojV" id="enter-invariants">Enter: invariants<a class="hash-link" href="#enter-invariants" title="Direct link to heading">​</a></h3><p>The insight is that it's not ok to use implied bounds out of thin air. You only want to use them for where-clauses that you have in scope. In this way, they are categorically different from program clauses, which always hold. I've decided to refer to implied bounds as <em>invariants</em> -- the idea is that they are things which "must be true if the program is valid". So for our program we would have one <strong>invariant</strong>:</p><div class="codeBlockContainer_MPoW theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_B9tL"><pre tabindex="0" class="prism-code language-text codeBlock__0OG thin-scrollbar"><code class="codeBlockLines_gEuF"><span class="token-line" style="color:#393A34"><span class="token plain">forall&lt;T&gt; { is-implemented(T: Magic) =&gt; is-implemented(T: Copy) }</span><br></span></code></pre><div class="buttonGroup_hRr1"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>To express this a bit more formally, let <code>F</code> be the set of all "facts" we can generate from the clauses alone (a "fact" here is just a predicate that refers to some concrete types and thing)s. Because there are an infinite set of types, the set of facts is also infinite, but that's ok. In our example, given the rules we've seen so far (but ignoring the implied bound), we can show that <code>has-impl(i32: Magic)</code> and <code>has-impl(u32: Magic)</code> easily enough. We don't have a <code>has-impl(i32: Copy)</code> fact, though, and because of that we also can't have a <code>is-implemented(i32: Copy)</code> fact. Given this set of facts <code>F</code>, then we ought to be able to prove each invariant <code>I</code>, or something is broken in our type rules. In our example, the invariant <code>forall&lt;T&gt; { is-implemented(T: Magic) =&gt; is-implemented(T: Copy) }</code> does in fact hold, because there are no <code>is-implemented(T: Magic)</code> facts.</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="integrating-invariants-into-the-solver">Integrating invariants into the solver<a class="hash-link" href="#integrating-invariants-into-the-solver" title="Direct link to heading">​</a></h3><p>The solver is able to make use of invariants to generate proofs, but only in a limited way. Whereas we can always use a program clause, we can only apply invariants to the <em>hypotheses</em> that are in scope -- a <em>hypotheses</em> is some where-clause that we are assuming to be true. The idea here is that the caller must have proven that hypothesis to be a <em>fact</em> -- if they did so, then unless our type rules are broken, the invariant holds, which means that any facts we can derive with the invariants are also true.</p><p>This in turn implies that the seemingly tautological impl of <code>Magic</code> is actually <strong>legal</strong>! Recall the "ok goals" we saw before, that are used to decide which declarations are legal. The "ok" goal for the magic impl looks like this:</p><div class="language-scheme codeBlockContainer_MPoW theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_B9tL"><pre tabindex="0" class="prism-code language-scheme codeBlock__0OG thin-scrollbar"><code class="codeBlockLines_gEuF"><span class="token-line" style="color:#393A34"><span class="token plain">(∀ ((type T))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        (implies ((is-implemented (Magic (T))))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 (is-implemented (Magic (T)))))</span><br></span></code></pre><div class="buttonGroup_hRr1"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Basically, "if we assume that <code>T: Magic</code> is implemented, then we can show that <code>T: Magic</code> is implemented". Well, that's obviously true.</p><p>OK, so the impl is legal, but what about this function <code>make_the_magic_happen</code>?</p><div class="language-rust codeBlockContainer_MPoW theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_B9tL"><pre tabindex="0" class="prism-code language-rust codeBlock__0OG thin-scrollbar"><code class="codeBlockLines_gEuF"><span class="token-line" style="color:#393A34"><span class="token plain">fn make_the_magic_happen&lt;T: Magic&gt;(t: T) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let u = t;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    drop((t, u)); // both t, u are valid</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_hRr1"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>We don't currently have type-checking logic in formality but, if we did, type-checking this function would require copying <code>t</code> and hence proving that:</p><div class="codeBlockContainer_MPoW theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_B9tL"><pre tabindex="0" class="prism-code language-text codeBlock__0OG thin-scrollbar"><code class="codeBlockLines_gEuF"><span class="token-line" style="color:#393A34"><span class="token plain">forall&lt;T&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    is-implemented(T: Magic) =&gt; is-implemented(T: Copy)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_hRr1"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Here the <code>is-implemented(T: Magic) =&gt; ...</code> comes from the where-clauses on the function. To solve this, the solver puts <code>is-implemented(T: Magic)</code> into the environment as a hypothesis using the "prove-implies" rule (<a href="https://github.com/nikomatsakis/a-mir-formality/blob/47eceea34b5f56a55d781acc73dca86c996b15c5/src/ty/cosld-solve/prove.rkt#L67-L71" target="_blank" rel="noopener noreferrer">source</a>):</p><div class="language-scheme codeBlockContainer_MPoW theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_B9tL"><pre tabindex="0" class="prism-code language-scheme codeBlock__0OG thin-scrollbar"><code class="codeBlockLines_gEuF"><span class="token-line" style="color:#393A34"><span class="token plain">  [(where Env_1 (env-with-hypotheses Env Hypotheses))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   (prove Env_1 Predicates_stack Goal EnvSubstitution_out)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   -------------------------------------------------------- "prove-implies"</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   (prove Env Predicates_stack (implies Hypotheses Goal) (reset Env () EnvSubstitution_out))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   ]</span><br></span></code></pre><div class="buttonGroup_hRr1"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Next it can apply the "prove-hypothesis-imply" rule (<a href="https://github.com/nikomatsakis/a-mir-formality/blob/47eceea34b5f56a55d781acc73dca86c996b15c5/src/ty/cosld-solve/prove.rkt#L41-L45" target="_blank" rel="noopener noreferrer">source</a>):</p><div class="language-scheme codeBlockContainer_MPoW theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_B9tL"><pre tabindex="0" class="prism-code language-scheme codeBlock__0OG thin-scrollbar"><code class="codeBlockLines_gEuF"><span class="token-line" style="color:#393A34"><span class="token plain">  [(where #f (in? Predicate Predicates_stack))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   (Hypotheses-imply Env () Predicate EnvSubstitution_out)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   --------------- "prove-hypotheses-imply"</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   (prove Env Predicates_stack Predicate EnvSubstitution_out)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   ]</span><br></span></code></pre><div class="buttonGroup_hRr1"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>This rule usess <a href="https://github.com/nikomatsakis/a-mir-formality/blob/47eceea34b5f56a55d781acc73dca86c996b15c5/src/ty/cosld-solve/hypothesize.rkt#L9-L11" target="_blank" rel="noopener noreferrer"><code>Hypotheses-imply</code></a>, another typing judgment which determines whether <code>Predicate</code> is either <em>directly</em> in the environment as a hypothesis <strong>or can be derived via an invariant</strong>. This last part is what we need here! The only hypothesis in the environment is <code>is-implemented(T: Magic)</code>, but we can use the invariant</p><div class="codeBlockContainer_MPoW theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_B9tL"><pre tabindex="0" class="prism-code language-text codeBlock__0OG thin-scrollbar"><code class="codeBlockLines_gEuF"><span class="token-line" style="color:#393A34"><span class="token plain">is-implemented(T: Magic) =&gt; is-implemented(T: Copy)</span><br></span></code></pre><div class="buttonGroup_hRr1"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>to expand that to <code>is-implemented(T: Copy)</code>, so we are happy.</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="wait-so-is-this-sound">Wait, so is this sound?<a class="hash-link" href="#wait-so-is-this-sound" title="Direct link to heading">​</a></h3><p>But accepting this impl and this function this doesn't mean we have an unsound program -- the question is, who is going to <em>call</em> that function, and with what type? And this is where the errors come in. Consider this <code>main</code> function:</p><div class="language-rust codeBlockContainer_MPoW theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_B9tL"><pre tabindex="0" class="prism-code language-rust codeBlock__0OG thin-scrollbar"><code class="codeBlockLines_gEuF"><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    make_the_magic_happen("Die, cruel world, die!".to_string());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_hRr1"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>For this program to type-check, we must prove the where-clauses on <code>make_the_magic_happen</code>, which means proving</p><div class="codeBlockContainer_MPoW theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_B9tL"><pre tabindex="0" class="prism-code language-text codeBlock__0OG thin-scrollbar"><code class="codeBlockLines_gEuF"><span class="token-line" style="color:#393A34"><span class="token plain">is-implemented(String: Magic)</span><br></span></code></pre><div class="buttonGroup_hRr1"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>But in this case, there are no hypotheses in the environment, so we can't make use of the invariants. We have to use the program clause, it requires also showing that <code>is-implemented(String: Copy)</code> which in turn means showing <code>has-impl(String: Copy)</code>, and we cannot do that.</p><p>Thinking a bit more abstractly, no matter what where clauses we have on various functions, we will "bottom out" in a <code>main</code> function somewhere, and <code>main</code> has no where clauses. Therefore, if our program relies on <code>is-implemented(i32: Magic)</code>, that must be provable in an environment with no hypotheses. Put another way, <code>is-implemented(i32: Magic)</code> must be a member of that infinite set of facts that we described earlier, the ones which categorize "everything that is true in this program". But we already argued that this set does not include <code>is-implemented(i32: Magic)</code>, because the only way to get such a fact is to use the program clause, and the program clause requires that <code>has-impl(i32: Copy)</code>, which is not true.</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="productivity-again">Productivity again?<a class="hash-link" href="#productivity-again" title="Direct link to heading">​</a></h3><p>xxx -- didn't get time to to finish this, but I think that you can frame the previous two sections in terms of the typical "productivity" rules. There is a nice thesis I've been slowly working through on this. The TL;DR is something like this: "we accept all cycles but require that for any proof of <code>is-implemented(T: Foo)</code>, <code>has-impl(T: Foo)</code> must appear somewhere in the cycle", but that's not quite stating it right.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="future-directions">Future directions<a class="hash-link" href="#future-directions" title="Direct link to heading">​</a></h2><p>Here are some of the next steps I've been thinking about and we could discuss:</p><ul><li>There are some fixes to how <code>Hypothesize-implies</code> works that I want to make (I think it should be "bottom-up", not "top-down" as it is today, if that makes sense -- basically adopt the elaboration strategy from)</li><li>Sketch out the MIR type-checker</li><li>Integrate higher-ranked types and regions, polonius, etc -- I've been reading up on subtyping systems and I think I have some ideas for a fresh approach here</li><li>Implement the "recursive solver" as a metafunction<ul><li>it is useful to be able to compare the "cosld-solver", which I believe is sound+complete, against ours, which (I hope) is merely sound</li></ul></li><li>Extend rustc with <code>-Zformality</code> to allow it to generate formality programs</li><li>Use PLT redex to fuzz the existing solver and test the "invariant logic"</li></ul><h1>Niko's FAQ</h1><h2 class="anchor anchorWithStickyNavbar_mojV" id="if-this-is-a-complete-model-isnt-that-just-an-implementation">If this is a complete model, isn't that just an implementation?<a class="hash-link" href="#if-this-is-a-complete-model-isnt-that-just-an-implementation" title="Direct link to heading">​</a></h2><p>Not really. It leaves out a ton of stuff:</p><ul><li>diagnostics</li><li>low-level ABI details</li><li>parser and concrete rust syntax</li><li>running C code and FFI (though you can imagine translating C code to equivalent unsafe Rust, which would be supported to some extent)</li><li>platform specific things, interactions with the operating system</li></ul><p>Currently, it's focusing on MIR and back, which means we can exclude a lot of things</p><ul><li>name resolution</li><li>layout (we can take struct layouts as inputs)</li><li></li></ul><h1>Questions</h1><h2 class="anchor anchorWithStickyNavbar_mojV" id="are-there-any-fundamental-differences-to-chalk-so-far">Are there any fundamental differences to Chalk, so far?<a class="hash-link" href="#are-there-any-fundamental-differences-to-chalk-so-far" title="Direct link to heading">​</a></h2><p>nikomatsakis: Yes. Chalk does not have the concept of invariants and handles implied bounds in a different way (<code>FromEnv</code> goals). Chalk also has one structural setup that has to be ported to formality -- it generates program clauses "on demand". This is required because actually the set of program clauses for a Rust program is potentially infinite (think of e.g. auto traits). I've been debating the best way to model this with PLT Redex and in particular whether it's important to preserve the various layers I've shown here, it might be easier if we merged everything into one.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="is-this-an-ideal-rust-model-or-a-practical-one">Is this an "ideal" Rust model, or a "practical" one?<a class="hash-link" href="#is-this-an-ideal-rust-model-or-a-practical-one" title="Direct link to heading">​</a></h2><ul><li>Current Rust semantics, or the one we want</li></ul><p>nikomatsakis: You're asking the right question, and it's something I wanted to discuss. Right now it's the "ideal" model in the sense that I am using it to show how some extensions to Rust would work, but I think it's important that it be the "practical" one too. It's not hard to disable the implied bounds (actually, limit them to supertraits) and remove support for cycles. What's a bit more interesting, and I'm not sure about it, is the best way to have "feature gates" so that we can show the "diff required" to support a new feature. </p><h2 class="anchor anchorWithStickyNavbar_mojV" id="is-it-practical-to-try-to-develop-chalk-alongside-ie-update-chalks-rules-as-a-mir-formality-is-updated">Is it practical to try to develop Chalk alongside? I.e. update Chalk's rules as a-mir-formality is updated?<a class="hash-link" href="#is-it-practical-to-try-to-develop-chalk-alongside-ie-update-chalks-rules-as-a-mir-formality-is-updated" title="Direct link to heading">​</a></h2><p>nikomatsakis: I think so, and I think we should. This is partly why Formality's structure intentionally mirrors Chalk (and it should eventually include the solver, so that we can show "these are things the compiler should be able to prove" versus "these are things that are provable"). The idea is that we can prototype and explore more quickly in this environment, but chalk would scale up to real programs (the PLT Redex solver is way too slow for that). Also, Chalk's structure would be more optimized for performance, for giving good error messages, for dealing with low-level ABI details, and all the other fun stuff that the model does NOT include.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="what-about-coq">What about Coq?<a class="hash-link" href="#what-about-coq" title="Direct link to heading">​</a></h2><blockquote><p>it seems that coq is the most popular at POPL etc. How well do you think the framework you're using will integrate into other PL tools/efforts?</p></blockquote><p>nikomatsakis: As you can see, the notation is quite high-level, so if nothing else I think it would be easy to manually transcribe things. But I would assume people have made efforts to "export" rules and things from PLT Redex to other formats.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="how-would-types-team-signoff-integrate-into-feature-process">How would types team signoff integrate into feature process?<a class="hash-link" href="#how-would-types-team-signoff-integrate-into-feature-process" title="Direct link to heading">​</a></h2><ul><li>add a checkbox "types team signoff" for new language features</li><li>open an issue on formality repository</li></ul><h2 class="anchor anchorWithStickyNavbar_mojV" id="howwhere-does-coercion-fit-in">How/where does coercion fit in?<a class="hash-link" href="#howwhere-does-coercion-fit-in" title="Direct link to heading">​</a></h2>]]></content>
        <author>
            <name>nikomatsakis</name>
        </author>
    </entry>
</feed>